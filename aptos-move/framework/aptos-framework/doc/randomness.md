
<a id="0x1_randomness"></a>

# Module `0x1::randomness`

This module provides access to *instant* secure randomness generated by the Aptos validators, as documented in
[AIP-41](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-41.md).

Secure randomness means (1) the randomness cannot be predicted ahead of time by validators, developers or users
and (2) the randomness cannot be biased in any way by validators, developers or users.

Security holds under the same proof-of-stake assumption that secures the Aptos network.


-  [Resource `PerBlockRandomness`](#0x1_randomness_PerBlockRandomness)
-  [Struct `RandomnessGeneratedEvent`](#0x1_randomness_RandomnessGeneratedEvent)
-  [Resource `Ghost$var`](#0x1_randomness_Ghost$var)
-  [Constants](#@Constants_0)
-  [Function `initialize`](#0x1_randomness_initialize)
-  [Function `on_new_block`](#0x1_randomness_on_new_block)
-  [Function `next_32_bytes`](#0x1_randomness_next_32_bytes)
-  [Function `bytes`](#0x1_randomness_bytes)
-  [Function `u8_integer`](#0x1_randomness_u8_integer)
-  [Function `u16_integer`](#0x1_randomness_u16_integer)
-  [Function `u32_integer`](#0x1_randomness_u32_integer)
-  [Function `u64_integer`](#0x1_randomness_u64_integer)
-  [Function `u128_integer`](#0x1_randomness_u128_integer)
-  [Function `u256_integer`](#0x1_randomness_u256_integer)
-  [Function `u256_integer_internal`](#0x1_randomness_u256_integer_internal)
-  [Function `u8_range`](#0x1_randomness_u8_range)
-  [Function `u16_range`](#0x1_randomness_u16_range)
-  [Function `u32_range`](#0x1_randomness_u32_range)
-  [Function `u64_range`](#0x1_randomness_u64_range)
-  [Function `u64_range_internal`](#0x1_randomness_u64_range_internal)
-  [Function `u128_range`](#0x1_randomness_u128_range)
-  [Function `u256_range`](#0x1_randomness_u256_range)
-  [Function `permutation`](#0x1_randomness_permutation)
-  [Function `safe_add_mod`](#0x1_randomness_safe_add_mod)
-  [Function `safe_add_mod_for_verification`](#0x1_randomness_safe_add_mod_for_verification)
-  [Function `fetch_and_increment_txn_counter`](#0x1_randomness_fetch_and_increment_txn_counter)
-  [Function `is_unbiasable`](#0x1_randomness_is_unbiasable)
-  [Specification](#@Specification_1)
    -  [Function `initialize`](#@Specification_1_initialize)
    -  [Function `on_new_block`](#@Specification_1_on_new_block)
    -  [Function `next_32_bytes`](#@Specification_1_next_32_bytes)
    -  [Function `u8_integer`](#@Specification_1_u8_integer)
    -  [Function `u16_integer`](#@Specification_1_u16_integer)
    -  [Function `u32_integer`](#@Specification_1_u32_integer)
    -  [Function `u64_integer`](#@Specification_1_u64_integer)
    -  [Function `u128_integer`](#@Specification_1_u128_integer)
    -  [Function `u256_integer`](#@Specification_1_u256_integer)
    -  [Function `u256_integer_internal`](#@Specification_1_u256_integer_internal)
    -  [Function `u8_range`](#@Specification_1_u8_range)
    -  [Function `u64_range`](#@Specification_1_u64_range)
    -  [Function `u256_range`](#@Specification_1_u256_range)
    -  [Function `permutation`](#@Specification_1_permutation)
    -  [Function `safe_add_mod_for_verification`](#@Specification_1_safe_add_mod_for_verification)
    -  [Function `fetch_and_increment_txn_counter`](#@Specification_1_fetch_and_increment_txn_counter)
    -  [Function `is_unbiasable`](#@Specification_1_is_unbiasable)


<pre><code>use 0x1::event;
use 0x1::hash;
use 0x1::option;
use 0x1::system_addresses;
use 0x1::transaction_context;
use 0x1::vector;
</code></pre>



<a id="0x1_randomness_PerBlockRandomness"></a>

## Resource `PerBlockRandomness`

32-byte randomness seed unique to every block.
This resource is updated in every block prologue.


<pre><code>struct PerBlockRandomness has drop, key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>epoch: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>round: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>seed: option::Option&lt;vector&lt;u8&gt;&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_randomness_RandomnessGeneratedEvent"></a>

## Struct `RandomnessGeneratedEvent`

Event emitted every time a public randomness API in this module is called.


<pre><code>&#35;[event]
struct RandomnessGeneratedEvent has drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_randomness_Ghost$var"></a>

## Resource `Ghost$var`



<pre><code>struct Ghost$var has copy, drop, store, key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>v: vector&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_randomness_MAX_U256"></a>



<pre><code>const MAX_U256: u256 &#61; 115792089237316195423570985008687907853269984665640564039457584007913129639935;
</code></pre>



<a id="0x1_randomness_DST"></a>



<pre><code>const DST: vector&lt;u8&gt; &#61; [65, 80, 84, 79, 83, 95, 82, 65, 78, 68, 79, 77, 78, 69, 83, 83];
</code></pre>



<a id="0x1_randomness_E_API_USE_IS_BIASIBLE"></a>

Randomness APIs calls must originate from a private entry function with
<code>&#35;[randomness]</code> annotation. Otherwise, malicious users can bias randomness result.


<pre><code>const E_API_USE_IS_BIASIBLE: u64 &#61; 1;
</code></pre>



<a id="0x1_randomness_initialize"></a>

## Function `initialize`

Called in genesis.move.
Must be called in tests to initialize the <code>PerBlockRandomness</code> resource.


<pre><code>public fun initialize(framework: &amp;signer)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun initialize(framework: &amp;signer) &#123;
    system_addresses::assert_aptos_framework(framework);
    if (!exists&lt;PerBlockRandomness&gt;(@aptos_framework)) &#123;
        move_to(framework, PerBlockRandomness &#123;
            epoch: 0,
            round: 0,
            seed: option::none(),
        &#125;);
    &#125;
&#125;
</code></pre>



</details>

<a id="0x1_randomness_on_new_block"></a>

## Function `on_new_block`

Invoked in block prologues to update the block-level randomness seed.


<pre><code>public(friend) fun on_new_block(vm: &amp;signer, epoch: u64, round: u64, seed_for_new_block: option::Option&lt;vector&lt;u8&gt;&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public(friend) fun on_new_block(vm: &amp;signer, epoch: u64, round: u64, seed_for_new_block: Option&lt;vector&lt;u8&gt;&gt;) acquires PerBlockRandomness &#123;
    system_addresses::assert_vm(vm);
    if (exists&lt;PerBlockRandomness&gt;(@aptos_framework)) &#123;
        let randomness &#61; borrow_global_mut&lt;PerBlockRandomness&gt;(@aptos_framework);
        randomness.epoch &#61; epoch;
        randomness.round &#61; round;
        randomness.seed &#61; seed_for_new_block;
    &#125;
&#125;
</code></pre>



</details>

<a id="0x1_randomness_next_32_bytes"></a>

## Function `next_32_bytes`

Generate the next 32 random bytes. Repeated calls will yield different results (assuming the collision-resistance
of the hash function).


<pre><code>fun next_32_bytes(): vector&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>fun next_32_bytes(): vector&lt;u8&gt; acquires PerBlockRandomness &#123;
    assert!(is_unbiasable(), E_API_USE_IS_BIASIBLE);

    let input &#61; DST;
    let randomness &#61; borrow_global&lt;PerBlockRandomness&gt;(@aptos_framework);
    let seed &#61; &#42;option::borrow(&amp;randomness.seed);

    vector::append(&amp;mut input, seed);
    vector::append(&amp;mut input, transaction_context::get_transaction_hash());
    vector::append(&amp;mut input, fetch_and_increment_txn_counter());
    hash::sha3_256(input)
&#125;
</code></pre>



</details>

<a id="0x1_randomness_bytes"></a>

## Function `bytes`

Generates a sequence of bytes uniformly at random


<pre><code>public fun bytes(n: u64): vector&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun bytes(n: u64): vector&lt;u8&gt; acquires PerBlockRandomness &#123;
    let v &#61; vector[];
    let c &#61; 0;
    while (c &lt; n) &#123;
        let blob &#61; next_32_bytes();
        vector::append(&amp;mut v, blob);

        c &#61; c &#43; 32;
    &#125;;

    if (c &gt; n) &#123;
        vector::trim(&amp;mut v, n);
    &#125;;

    event::emit(RandomnessGeneratedEvent &#123;&#125;);

    v
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u8_integer"></a>

## Function `u8_integer`

Generates an u8 uniformly at random.


<pre><code>public fun u8_integer(): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun u8_integer(): u8 acquires PerBlockRandomness &#123;
    let raw &#61; next_32_bytes();
    let ret: u8 &#61; vector::pop_back(&amp;mut raw);

    event::emit(RandomnessGeneratedEvent &#123;&#125;);

    ret
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u16_integer"></a>

## Function `u16_integer`

Generates an u16 uniformly at random.


<pre><code>public fun u16_integer(): u16
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun u16_integer(): u16 acquires PerBlockRandomness &#123;
    let raw &#61; next_32_bytes();
    let i &#61; 0;
    let ret: u16 &#61; 0;
    while (i &lt; 2) &#123;
        ret &#61; ret &#42; 256 &#43; (vector::pop_back(&amp;mut raw) as u16);
        i &#61; i &#43; 1;
    &#125;;

    event::emit(RandomnessGeneratedEvent &#123;&#125;);

    ret
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u32_integer"></a>

## Function `u32_integer`

Generates an u32 uniformly at random.


<pre><code>public fun u32_integer(): u32
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun u32_integer(): u32 acquires PerBlockRandomness &#123;
    let raw &#61; next_32_bytes();
    let i &#61; 0;
    let ret: u32 &#61; 0;
    while (i &lt; 4) &#123;
        ret &#61; ret &#42; 256 &#43; (vector::pop_back(&amp;mut raw) as u32);
        i &#61; i &#43; 1;
    &#125;;

    event::emit(RandomnessGeneratedEvent &#123;&#125;);

    ret
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u64_integer"></a>

## Function `u64_integer`

Generates an u64 uniformly at random.


<pre><code>public fun u64_integer(): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun u64_integer(): u64 acquires PerBlockRandomness &#123;
    let raw &#61; next_32_bytes();
    let i &#61; 0;
    let ret: u64 &#61; 0;
    while (i &lt; 8) &#123;
        ret &#61; ret &#42; 256 &#43; (vector::pop_back(&amp;mut raw) as u64);
        i &#61; i &#43; 1;
    &#125;;

    event::emit(RandomnessGeneratedEvent &#123;&#125;);

    ret
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u128_integer"></a>

## Function `u128_integer`

Generates an u128 uniformly at random.


<pre><code>public fun u128_integer(): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun u128_integer(): u128 acquires PerBlockRandomness &#123;
    let raw &#61; next_32_bytes();
    let i &#61; 0;
    let ret: u128 &#61; 0;
    while (i &lt; 16) &#123;
        ret &#61; ret &#42; 256 &#43; (vector::pop_back(&amp;mut raw) as u128);
        i &#61; i &#43; 1;
    &#125;;

    event::emit(RandomnessGeneratedEvent &#123;&#125;);

    ret
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u256_integer"></a>

## Function `u256_integer`

Generates a u256 uniformly at random.


<pre><code>public fun u256_integer(): u256
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun u256_integer(): u256 acquires PerBlockRandomness &#123;
    event::emit(RandomnessGeneratedEvent &#123;&#125;);
    u256_integer_internal()
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u256_integer_internal"></a>

## Function `u256_integer_internal`

Generates a u256 uniformly at random.


<pre><code>fun u256_integer_internal(): u256
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>fun u256_integer_internal(): u256 acquires PerBlockRandomness &#123;
    let raw &#61; next_32_bytes();
    let i &#61; 0;
    let ret: u256 &#61; 0;
    while (i &lt; 32) &#123;
        ret &#61; ret &#42; 256 &#43; (vector::pop_back(&amp;mut raw) as u256);
        i &#61; i &#43; 1;
    &#125;;
    ret
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u8_range"></a>

## Function `u8_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.


<pre><code>public fun u8_range(min_incl: u8, max_excl: u8): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun u8_range(min_incl: u8, max_excl: u8): u8 acquires PerBlockRandomness &#123;
    let range &#61; ((max_excl &#45; min_incl) as u256);
    let sample &#61; ((u256_integer_internal() % range) as u8);

    event::emit(RandomnessGeneratedEvent &#123;&#125;);

    min_incl &#43; sample
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u16_range"></a>

## Function `u16_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.


<pre><code>public fun u16_range(min_incl: u16, max_excl: u16): u16
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun u16_range(min_incl: u16, max_excl: u16): u16 acquires PerBlockRandomness &#123;
    let range &#61; ((max_excl &#45; min_incl) as u256);
    let sample &#61; ((u256_integer_internal() % range) as u16);

    event::emit(RandomnessGeneratedEvent &#123;&#125;);

    min_incl &#43; sample
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u32_range"></a>

## Function `u32_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.


<pre><code>public fun u32_range(min_incl: u32, max_excl: u32): u32
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun u32_range(min_incl: u32, max_excl: u32): u32 acquires PerBlockRandomness &#123;
    let range &#61; ((max_excl &#45; min_incl) as u256);
    let sample &#61; ((u256_integer_internal() % range) as u32);

    event::emit(RandomnessGeneratedEvent &#123;&#125;);

    min_incl &#43; sample
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u64_range"></a>

## Function `u64_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.


<pre><code>public fun u64_range(min_incl: u64, max_excl: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun u64_range(min_incl: u64, max_excl: u64): u64 acquires PerBlockRandomness &#123;
    event::emit(RandomnessGeneratedEvent &#123;&#125;);

    u64_range_internal(min_incl, max_excl)
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u64_range_internal"></a>

## Function `u64_range_internal`



<pre><code>public fun u64_range_internal(min_incl: u64, max_excl: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun u64_range_internal(min_incl: u64, max_excl: u64): u64 acquires PerBlockRandomness &#123;
    let range &#61; ((max_excl &#45; min_incl) as u256);
    let sample &#61; ((u256_integer_internal() % range) as u64);

    min_incl &#43; sample
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u128_range"></a>

## Function `u128_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.


<pre><code>public fun u128_range(min_incl: u128, max_excl: u128): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun u128_range(min_incl: u128, max_excl: u128): u128 acquires PerBlockRandomness &#123;
    let range &#61; ((max_excl &#45; min_incl) as u256);
    let sample &#61; ((u256_integer_internal() % range) as u128);

    event::emit(RandomnessGeneratedEvent &#123;&#125;);

    min_incl &#43; sample
&#125;
</code></pre>



</details>

<a id="0x1_randomness_u256_range"></a>

## Function `u256_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own with <code>u256_integer()</code> + rejection sampling.


<pre><code>public fun u256_range(min_incl: u256, max_excl: u256): u256
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun u256_range(min_incl: u256, max_excl: u256): u256 acquires PerBlockRandomness &#123;
    let range &#61; max_excl &#45; min_incl;
    let r0 &#61; u256_integer_internal();
    let r1 &#61; u256_integer_internal();

    // Will compute sample :&#61; (r0 &#43; r1&#42;2^256) % range.

    let sample &#61; r1 % range;
    let i &#61; 0;
    while (&#123;
        spec &#123;
            invariant sample &gt;&#61; 0 &amp;&amp; sample &lt; max_excl &#45; min_incl;
        &#125;;
        i &lt; 256
    &#125;) &#123;
        sample &#61; safe_add_mod(sample, sample, range);
        i &#61; i &#43; 1;
    &#125;;

    let sample &#61; safe_add_mod(sample, r0 % range, range);
    spec &#123;
        assert sample &gt;&#61; 0 &amp;&amp; sample &lt; max_excl &#45; min_incl;
    &#125;;

    event::emit(RandomnessGeneratedEvent &#123;&#125;);

    min_incl &#43; sample
&#125;
</code></pre>



</details>

<a id="0x1_randomness_permutation"></a>

## Function `permutation`

Generate a permutation of <code>[0, 1, ..., n&#45;1]</code> uniformly at random.
If n is 0, returns the empty vector.


<pre><code>public fun permutation(n: u64): vector&lt;u64&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun permutation(n: u64): vector&lt;u64&gt; acquires PerBlockRandomness &#123;
    let values &#61; vector[];

    if(n &#61;&#61; 0) &#123;
        return vector[]
    &#125;;

    // Initialize into [0, 1, ..., n&#45;1].
    let i &#61; 0;
    while (&#123;
        spec &#123;
            invariant i &lt;&#61; n;
            invariant len(values) &#61;&#61; i;
        &#125;;
        i &lt; n
    &#125;) &#123;
        std::vector::push_back(&amp;mut values, i);
        i &#61; i &#43; 1;
    &#125;;
    spec &#123;
        assert len(values) &#61;&#61; n;
    &#125;;

    // Shuffle.
    let tail &#61; n &#45; 1;
    while (&#123;
        spec &#123;
            invariant tail &gt;&#61; 0 &amp;&amp; tail &lt; len(values);
        &#125;;
        tail &gt; 0
    &#125;) &#123;
        let pop_position &#61; u64_range_internal(0, tail &#43; 1);
        spec &#123;
            assert pop_position &lt; len(values);
        &#125;;
        std::vector::swap(&amp;mut values, pop_position, tail);
        tail &#61; tail &#45; 1;
    &#125;;

    event::emit(RandomnessGeneratedEvent &#123;&#125;);

    values
&#125;
</code></pre>



</details>

<a id="0x1_randomness_safe_add_mod"></a>

## Function `safe_add_mod`

Compute <code>(a &#43; b) % m</code>, assuming <code>m &gt;&#61; 1, 0 &lt;&#61; a &lt; m, 0&lt;&#61; b &lt; m</code>.


<pre><code>fun safe_add_mod(a: u256, b: u256, m: u256): u256
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>inline fun safe_add_mod(a: u256, b: u256, m: u256): u256 &#123;
    let neg_b &#61; m &#45; b;
    if (a &lt; neg_b) &#123;
        a &#43; b
    &#125; else &#123;
        a &#45; neg_b
    &#125;
&#125;
</code></pre>



</details>

<a id="0x1_randomness_safe_add_mod_for_verification"></a>

## Function `safe_add_mod_for_verification`



<pre><code>&#35;[verify_only]
fun safe_add_mod_for_verification(a: u256, b: u256, m: u256): u256
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>fun safe_add_mod_for_verification(a: u256, b: u256, m: u256): u256 &#123;
    let neg_b &#61; m &#45; b;
    if (a &lt; neg_b) &#123;
        a &#43; b
    &#125; else &#123;
        a &#45; neg_b
    &#125;
&#125;
</code></pre>



</details>

<a id="0x1_randomness_fetch_and_increment_txn_counter"></a>

## Function `fetch_and_increment_txn_counter`

Fetches and increments a transaction-specific 32-byte randomness-related counter.
Aborts with <code>E_API_USE_SUSCEPTIBLE_TO_TEST_AND_ABORT</code> if randomness is not unbiasable.


<pre><code>fun fetch_and_increment_txn_counter(): vector&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun fetch_and_increment_txn_counter(): vector&lt;u8&gt;;
</code></pre>



</details>

<a id="0x1_randomness_is_unbiasable"></a>

## Function `is_unbiasable`

Called in each randomness generation function to ensure certain safety invariants, namely:
1. The transaction that led to the call of this function had a private (or friend) entry
function as its payload.
2. The entry function had <code>&#35;[randomness]</code> annotation.


<pre><code>fun is_unbiasable(): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun is_unbiasable(): bool;
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification



<pre><code>pragma verify &#61; true;
invariant [suspendable] chain_status::is_operating() &#61;&#61;&gt; exists&lt;PerBlockRandomness&gt;(@aptos_framework);
<a id="0x1_randomness_var"></a>
global var: vector&lt;u8&gt;;
</code></pre>



<a id="@Specification_1_initialize"></a>

### Function `initialize`


<pre><code>public fun initialize(framework: &amp;signer)
</code></pre>




<pre><code>let framework_addr &#61; signer::address_of(framework);
aborts_if framework_addr !&#61; @aptos_framework;
</code></pre>



<a id="@Specification_1_on_new_block"></a>

### Function `on_new_block`


<pre><code>public(friend) fun on_new_block(vm: &amp;signer, epoch: u64, round: u64, seed_for_new_block: option::Option&lt;vector&lt;u8&gt;&gt;)
</code></pre>




<pre><code>aborts_if signer::address_of(vm) !&#61; @vm;
ensures exists&lt;PerBlockRandomness&gt;(@aptos_framework) &#61;&#61;&gt; global&lt;PerBlockRandomness&gt;(@aptos_framework).seed &#61;&#61; seed_for_new_block;
ensures exists&lt;PerBlockRandomness&gt;(@aptos_framework) &#61;&#61;&gt; global&lt;PerBlockRandomness&gt;(@aptos_framework).epoch &#61;&#61; epoch;
ensures exists&lt;PerBlockRandomness&gt;(@aptos_framework) &#61;&#61;&gt; global&lt;PerBlockRandomness&gt;(@aptos_framework).round &#61;&#61; round;
</code></pre>



<a id="@Specification_1_next_32_bytes"></a>

### Function `next_32_bytes`


<pre><code>fun next_32_bytes(): vector&lt;u8&gt;
</code></pre>




<pre><code>include NextBlobAbortsIf;
let input &#61; b&quot;APTOS_RANDOMNESS&quot;;
let randomness &#61; global&lt;PerBlockRandomness&gt;(@aptos_framework);
let seed &#61; option::spec_borrow(randomness.seed);
let txn_hash &#61; transaction_context::spec_get_txn_hash();
let txn_counter &#61; spec_fetch_and_increment_txn_counter();
ensures len(result) &#61;&#61; 32;
ensures result &#61;&#61; hash::sha3_256(concat(concat(concat(input, seed), txn_hash), txn_counter));
</code></pre>




<a id="0x1_randomness_NextBlobAbortsIf"></a>


<pre><code>schema NextBlobAbortsIf &#123;
    let randomness &#61; global&lt;PerBlockRandomness&gt;(@aptos_framework);
    aborts_if option::spec_is_none(randomness.seed);
    aborts_if !spec_is_unbiasable();
    aborts_if !exists&lt;PerBlockRandomness&gt;(@aptos_framework);
&#125;
</code></pre>



<a id="@Specification_1_u8_integer"></a>

### Function `u8_integer`


<pre><code>public fun u8_integer(): u8
</code></pre>




<pre><code>include NextBlobAbortsIf;
</code></pre>



<a id="@Specification_1_u16_integer"></a>

### Function `u16_integer`


<pre><code>public fun u16_integer(): u16
</code></pre>




<pre><code>pragma unroll &#61; 2;
include NextBlobAbortsIf;
</code></pre>



<a id="@Specification_1_u32_integer"></a>

### Function `u32_integer`


<pre><code>public fun u32_integer(): u32
</code></pre>




<pre><code>pragma unroll &#61; 4;
include NextBlobAbortsIf;
</code></pre>



<a id="@Specification_1_u64_integer"></a>

### Function `u64_integer`


<pre><code>public fun u64_integer(): u64
</code></pre>




<pre><code>pragma unroll &#61; 8;
include NextBlobAbortsIf;
</code></pre>



<a id="@Specification_1_u128_integer"></a>

### Function `u128_integer`


<pre><code>public fun u128_integer(): u128
</code></pre>




<pre><code>pragma unroll &#61; 16;
include NextBlobAbortsIf;
</code></pre>



<a id="@Specification_1_u256_integer"></a>

### Function `u256_integer`


<pre><code>public fun u256_integer(): u256
</code></pre>




<pre><code>pragma verify_duration_estimate &#61; 300;
pragma unroll &#61; 32;
include NextBlobAbortsIf;
ensures [abstract] result &#61;&#61; spec_u256_integer();
</code></pre>



<a id="@Specification_1_u256_integer_internal"></a>

### Function `u256_integer_internal`


<pre><code>fun u256_integer_internal(): u256
</code></pre>




<pre><code>pragma unroll &#61; 32;
include NextBlobAbortsIf;
</code></pre>




<a id="0x1_randomness_spec_u256_integer"></a>


<pre><code>fun spec_u256_integer(): u256;
</code></pre>



<a id="@Specification_1_u8_range"></a>

### Function `u8_range`


<pre><code>public fun u8_range(min_incl: u8, max_excl: u8): u8
</code></pre>




<pre><code>pragma verify_duration_estimate &#61; 120;
pragma opaque;
include NextBlobAbortsIf;
aborts_if min_incl &gt;&#61; max_excl;
ensures result &gt;&#61; min_incl &amp;&amp; result &lt; max_excl;
</code></pre>



<a id="@Specification_1_u64_range"></a>

### Function `u64_range`


<pre><code>public fun u64_range(min_incl: u64, max_excl: u64): u64
</code></pre>




<pre><code>pragma verify_duration_estimate &#61; 120;
include NextBlobAbortsIf;
aborts_if min_incl &gt;&#61; max_excl;
ensures result &gt;&#61; min_incl &amp;&amp; result &lt; max_excl;
</code></pre>



<a id="@Specification_1_u256_range"></a>

### Function `u256_range`


<pre><code>public fun u256_range(min_incl: u256, max_excl: u256): u256
</code></pre>




<pre><code>pragma verify_duration_estimate &#61; 120;
include NextBlobAbortsIf;
aborts_if min_incl &gt;&#61; max_excl;
ensures result &gt;&#61; min_incl &amp;&amp; result &lt; max_excl;
</code></pre>



<a id="@Specification_1_permutation"></a>

### Function `permutation`


<pre><code>public fun permutation(n: u64): vector&lt;u64&gt;
</code></pre>




<pre><code>pragma aborts_if_is_partial;
</code></pre>



<a id="@Specification_1_safe_add_mod_for_verification"></a>

### Function `safe_add_mod_for_verification`


<pre><code>&#35;[verify_only]
fun safe_add_mod_for_verification(a: u256, b: u256, m: u256): u256
</code></pre>




<pre><code>aborts_if m &lt; b;
aborts_if a &lt; m &#45; b &amp;&amp; a &#43; b &gt; MAX_U256;
ensures result &#61;&#61; spec_safe_add_mod(a, b, m);
</code></pre>




<a id="0x1_randomness_spec_safe_add_mod"></a>


<pre><code>fun spec_safe_add_mod(a: u256, b: u256, m: u256): u256 &#123;
   if (a &lt; m &#45; b) &#123;
       a &#43; b
   &#125; else &#123;
       a &#45; (m &#45; b)
   &#125;
&#125;
</code></pre>



<a id="@Specification_1_fetch_and_increment_txn_counter"></a>

### Function `fetch_and_increment_txn_counter`


<pre><code>fun fetch_and_increment_txn_counter(): vector&lt;u8&gt;
</code></pre>




<pre><code>pragma opaque;
aborts_if [abstract] false;
ensures [abstract] result &#61;&#61; spec_fetch_and_increment_txn_counter();
</code></pre>




<a id="0x1_randomness_spec_fetch_and_increment_txn_counter"></a>


<pre><code>fun spec_fetch_and_increment_txn_counter(): vector&lt;u8&gt;;
</code></pre>



<a id="@Specification_1_is_unbiasable"></a>

### Function `is_unbiasable`


<pre><code>fun is_unbiasable(): bool
</code></pre>




<pre><code>pragma opaque;
aborts_if [abstract] false;
ensures [abstract] result &#61;&#61; spec_is_unbiasable();
</code></pre>




<a id="0x1_randomness_spec_is_unbiasable"></a>


<pre><code>fun spec_is_unbiasable(): bool;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY
