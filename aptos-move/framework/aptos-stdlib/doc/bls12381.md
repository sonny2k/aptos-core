
<a id="0x1_bls12381"></a>

# Module `0x1::bls12381`

Contains functions for:

The minimum-pubkey-size variant of [Boneh-Lynn-Shacham (BLS) signatures](https://en.wikipedia.org/wiki/BLS_digital_signature),
where public keys are BLS12-381 elliptic-curve points in $\mathbb{G}_1$ and signatures are in $\mathbb{G}_2$,
as per the [IETF BLS draft standard](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature#section-2.1).


-  [Struct `PublicKey`](#0x1_bls12381_PublicKey)
-  [Struct `ProofOfPossession`](#0x1_bls12381_ProofOfPossession)
-  [Struct `PublicKeyWithPoP`](#0x1_bls12381_PublicKeyWithPoP)
-  [Struct `AggrPublicKeysWithPoP`](#0x1_bls12381_AggrPublicKeysWithPoP)
-  [Struct `Signature`](#0x1_bls12381_Signature)
-  [Struct `AggrOrMultiSignature`](#0x1_bls12381_AggrOrMultiSignature)
-  [Constants](#@Constants_0)
-  [Function `public_key_from_bytes`](#0x1_bls12381_public_key_from_bytes)
-  [Function `public_key_to_bytes`](#0x1_bls12381_public_key_to_bytes)
-  [Function `proof_of_possession_from_bytes`](#0x1_bls12381_proof_of_possession_from_bytes)
-  [Function `proof_of_possession_to_bytes`](#0x1_bls12381_proof_of_possession_to_bytes)
-  [Function `public_key_from_bytes_with_pop`](#0x1_bls12381_public_key_from_bytes_with_pop)
-  [Function `public_key_with_pop_to_normal`](#0x1_bls12381_public_key_with_pop_to_normal)
-  [Function `public_key_with_pop_to_bytes`](#0x1_bls12381_public_key_with_pop_to_bytes)
-  [Function `signature_from_bytes`](#0x1_bls12381_signature_from_bytes)
-  [Function `signature_to_bytes`](#0x1_bls12381_signature_to_bytes)
-  [Function `signature_subgroup_check`](#0x1_bls12381_signature_subgroup_check)
-  [Function `aggregate_pubkeys`](#0x1_bls12381_aggregate_pubkeys)
-  [Function `aggregate_pubkey_to_bytes`](#0x1_bls12381_aggregate_pubkey_to_bytes)
-  [Function `aggregate_signatures`](#0x1_bls12381_aggregate_signatures)
-  [Function `aggr_or_multi_signature_to_bytes`](#0x1_bls12381_aggr_or_multi_signature_to_bytes)
-  [Function `aggr_or_multi_signature_from_bytes`](#0x1_bls12381_aggr_or_multi_signature_from_bytes)
-  [Function `aggr_or_multi_signature_subgroup_check`](#0x1_bls12381_aggr_or_multi_signature_subgroup_check)
-  [Function `verify_aggregate_signature`](#0x1_bls12381_verify_aggregate_signature)
-  [Function `verify_multisignature`](#0x1_bls12381_verify_multisignature)
-  [Function `verify_normal_signature`](#0x1_bls12381_verify_normal_signature)
-  [Function `verify_signature_share`](#0x1_bls12381_verify_signature_share)
-  [Function `aggregate_pubkeys_internal`](#0x1_bls12381_aggregate_pubkeys_internal)
-  [Function `aggregate_signatures_internal`](#0x1_bls12381_aggregate_signatures_internal)
-  [Function `validate_pubkey_internal`](#0x1_bls12381_validate_pubkey_internal)
-  [Function `signature_subgroup_check_internal`](#0x1_bls12381_signature_subgroup_check_internal)
-  [Function `verify_aggregate_signature_internal`](#0x1_bls12381_verify_aggregate_signature_internal)
-  [Function `verify_multisignature_internal`](#0x1_bls12381_verify_multisignature_internal)
-  [Function `verify_normal_signature_internal`](#0x1_bls12381_verify_normal_signature_internal)
-  [Function `verify_proof_of_possession_internal`](#0x1_bls12381_verify_proof_of_possession_internal)
-  [Function `verify_signature_share_internal`](#0x1_bls12381_verify_signature_share_internal)
-  [Specification](#@Specification_1)
    -  [Function `public_key_from_bytes`](#@Specification_1_public_key_from_bytes)
    -  [Function `public_key_from_bytes_with_pop`](#@Specification_1_public_key_from_bytes_with_pop)
    -  [Function `aggregate_pubkeys`](#@Specification_1_aggregate_pubkeys)
    -  [Function `aggregate_signatures`](#@Specification_1_aggregate_signatures)
    -  [Function `aggr_or_multi_signature_from_bytes`](#@Specification_1_aggr_or_multi_signature_from_bytes)
    -  [Function `aggr_or_multi_signature_subgroup_check`](#@Specification_1_aggr_or_multi_signature_subgroup_check)
    -  [Function `verify_aggregate_signature`](#@Specification_1_verify_aggregate_signature)
    -  [Function `verify_multisignature`](#@Specification_1_verify_multisignature)
    -  [Function `verify_normal_signature`](#@Specification_1_verify_normal_signature)
    -  [Function `verify_signature_share`](#@Specification_1_verify_signature_share)
    -  [Function `aggregate_pubkeys_internal`](#@Specification_1_aggregate_pubkeys_internal)
    -  [Function `aggregate_signatures_internal`](#@Specification_1_aggregate_signatures_internal)
    -  [Function `validate_pubkey_internal`](#@Specification_1_validate_pubkey_internal)
    -  [Function `signature_subgroup_check_internal`](#@Specification_1_signature_subgroup_check_internal)
    -  [Function `verify_aggregate_signature_internal`](#@Specification_1_verify_aggregate_signature_internal)
    -  [Function `verify_multisignature_internal`](#@Specification_1_verify_multisignature_internal)
    -  [Function `verify_normal_signature_internal`](#@Specification_1_verify_normal_signature_internal)
    -  [Function `verify_proof_of_possession_internal`](#@Specification_1_verify_proof_of_possession_internal)
    -  [Function `verify_signature_share_internal`](#@Specification_1_verify_signature_share_internal)
    -  [Helper functions](#@Helper_functions_2)


<pre><code>use 0x1::error;
use 0x1::option;
</code></pre>



<a id="0x1_bls12381_PublicKey"></a>

## Struct `PublicKey`

A *validated* public key that:
(1) is a point in the prime-order subgroup of the BLS12-381 elliptic curve, and
(2) is not the identity point

This struct can be used to verify a normal (non-aggregated) signature.

This struct can be combined with a ProofOfPossession struct in order to create a PublicKeyWithPop struct, which
can be used to verify a multisignature.


<pre><code>struct PublicKey has copy, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: vector&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_ProofOfPossession"></a>

## Struct `ProofOfPossession`

A proof-of-possession (PoP).
Given such a struct and a PublicKey struct, one can construct a PublicKeyWithPoP (see below).


<pre><code>struct ProofOfPossession has copy, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: vector&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_PublicKeyWithPoP"></a>

## Struct `PublicKeyWithPoP`

A *validated* public key that had a successfully-verified proof-of-possession (PoP).

A vector of these structs can be either:
(1) used to verify an aggregate signature
(2) aggregated with other PublicKeyWithPoP structs into an AggrPublicKeysWithPoP, which in turn can be used
to verify a multisignature


<pre><code>struct PublicKeyWithPoP has copy, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: vector&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_AggrPublicKeysWithPoP"></a>

## Struct `AggrPublicKeysWithPoP`

An aggregation of public keys with verified PoPs, which can be used to verify multisignatures.


<pre><code>struct AggrPublicKeysWithPoP has copy, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: vector&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_Signature"></a>

## Struct `Signature`

A BLS signature. This can be either a:
(1) normal (non-aggregated) signature
(2) signature share (for a multisignature or aggregate signature)


<pre><code>struct Signature has copy, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: vector&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_AggrOrMultiSignature"></a>

## Struct `AggrOrMultiSignature`

An aggregation of BLS signatures. This can be either a:
(4) aggregated signature (i.e., an aggregation of signatures s_i, each on a message m_i)
(3) multisignature (i.e., an aggregation of signatures s_i, each on the same message m)

We distinguish between a Signature type and a AggrOrMultiSignature type to prevent developers from interchangeably
calling <code>verify_multisignature</code> and <code>verify_signature_share</code> to verify both multisignatures and signature shares,
which could create problems down the line.


<pre><code>struct AggrOrMultiSignature has copy, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: vector&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_bls12381_EWRONG_SIZE"></a>

One of the given inputs has the wrong size.s


<pre><code>const EWRONG_SIZE: u64 &#61; 2;
</code></pre>



<a id="0x1_bls12381_EZERO_PUBKEYS"></a>

The caller was supposed to input one or more public keys.


<pre><code>const EZERO_PUBKEYS: u64 &#61; 1;
</code></pre>



<a id="0x1_bls12381_E_NUM_SIGNERS_MUST_EQ_NUM_MESSAGES"></a>

The number of signers does not match the number of messages to be signed.


<pre><code>const E_NUM_SIGNERS_MUST_EQ_NUM_MESSAGES: u64 &#61; 3;
</code></pre>



<a id="0x1_bls12381_PUBLIC_KEY_NUM_BYTES"></a>

The public key size, in bytes


<pre><code>const PUBLIC_KEY_NUM_BYTES: u64 &#61; 48;
</code></pre>



<a id="0x1_bls12381_RANDOM_PK"></a>

Random signature generated by running <code>cargo test &#45;&#45; bls12381_sample_signature &#45;&#45;nocapture &#45;&#45;include&#45;ignored</code> in <code>crates/aptos&#45;crypto</code>.
The associated SK is 07416693b6b32c84abe45578728e2379f525729e5b94762435a31e65ecc728da.


<pre><code>const RANDOM_PK: vector&lt;u8&gt; &#61; [138, 83, 231, 174, 82, 112, 227, 231, 101, 205, 138, 64, 50, 194, 231, 124, 111, 126, 135, 164, 78, 187, 133, 191, 40, 164, 215, 134, 85, 101, 105, 143, 151, 83, 70, 113, 66, 98, 249, 228, 124, 111, 62, 13, 93, 149, 22, 96];
</code></pre>



<a id="0x1_bls12381_RANDOM_SIGNATURE"></a>

Random signature generated by running <code>cargo test &#45;&#45; bls12381_sample_signature &#45;&#45;nocapture &#45;&#45;include&#45;ignored</code> in <code>crates/aptos&#45;crypto</code>.
The message signed is "Hello Aptos!" and the associated SK is 07416693b6b32c84abe45578728e2379f525729e5b94762435a31e65ecc728da.


<pre><code>const RANDOM_SIGNATURE: vector&lt;u8&gt; &#61; [160, 26, 101, 133, 79, 152, 125, 52, 52, 20, 155, 127, 8, 247, 7, 48, 227, 11, 36, 25, 132, 232, 113, 43, 194, 172, 168, 133, 214, 50, 170, 252, 237, 76, 63, 102, 18, 9, 222, 187, 107, 28, 134, 1, 50, 102, 35, 204, 22, 202, 47, 108, 158, 220, 83, 183, 184, 139, 116, 53, 251, 107, 5, 221, 236, 228, 24, 210, 195, 77, 198, 172, 162, 245, 161, 26, 121, 230, 119, 116, 88, 44, 20, 8, 74, 1, 220, 183, 130, 14, 76, 180, 186, 208, 234, 141];
</code></pre>



<a id="0x1_bls12381_SIGNATURE_SIZE"></a>

The signature size, in bytes


<pre><code>const SIGNATURE_SIZE: u64 &#61; 96;
</code></pre>



<a id="0x1_bls12381_public_key_from_bytes"></a>

## Function `public_key_from_bytes`

Creates a new public key from a sequence of bytes.


<pre><code>public fun public_key_from_bytes(bytes: vector&lt;u8&gt;): option::Option&lt;bls12381::PublicKey&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun public_key_from_bytes(bytes: vector&lt;u8&gt;): Option&lt;PublicKey&gt; &#123;
    if (validate_pubkey_internal(bytes)) &#123;
        option::some(PublicKey &#123;
            bytes
        &#125;)
    &#125; else &#123;
        option::none&lt;PublicKey&gt;()
    &#125;
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_public_key_to_bytes"></a>

## Function `public_key_to_bytes`

Serializes a public key into 48 bytes.


<pre><code>public fun public_key_to_bytes(pk: &amp;bls12381::PublicKey): vector&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun public_key_to_bytes(pk: &amp;PublicKey): vector&lt;u8&gt; &#123;
    pk.bytes
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_proof_of_possession_from_bytes"></a>

## Function `proof_of_possession_from_bytes`

Creates a new proof-of-possession (PoP) which can be later used to create a PublicKeyWithPoP struct,


<pre><code>public fun proof_of_possession_from_bytes(bytes: vector&lt;u8&gt;): bls12381::ProofOfPossession
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun proof_of_possession_from_bytes(bytes: vector&lt;u8&gt;): ProofOfPossession &#123;
    ProofOfPossession &#123;
        bytes
    &#125;
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_proof_of_possession_to_bytes"></a>

## Function `proof_of_possession_to_bytes`

Serializes the signature into 96 bytes.


<pre><code>public fun proof_of_possession_to_bytes(pop: &amp;bls12381::ProofOfPossession): vector&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun proof_of_possession_to_bytes(pop: &amp;ProofOfPossession): vector&lt;u8&gt; &#123;
    pop.bytes
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_public_key_from_bytes_with_pop"></a>

## Function `public_key_from_bytes_with_pop`

Creates a PoP'd public key from a normal public key and a corresponding proof-of-possession.


<pre><code>public fun public_key_from_bytes_with_pop(pk_bytes: vector&lt;u8&gt;, pop: &amp;bls12381::ProofOfPossession): option::Option&lt;bls12381::PublicKeyWithPoP&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun public_key_from_bytes_with_pop(pk_bytes: vector&lt;u8&gt;, pop: &amp;ProofOfPossession): Option&lt;PublicKeyWithPoP&gt; &#123;
    if (verify_proof_of_possession_internal(pk_bytes, pop.bytes)) &#123;
        option::some(PublicKeyWithPoP &#123;
            bytes: pk_bytes
        &#125;)
    &#125; else &#123;
        option::none&lt;PublicKeyWithPoP&gt;()
    &#125;
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_public_key_with_pop_to_normal"></a>

## Function `public_key_with_pop_to_normal`

Creates a normal public key from a PoP'd public key.


<pre><code>public fun public_key_with_pop_to_normal(pkpop: &amp;bls12381::PublicKeyWithPoP): bls12381::PublicKey
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun public_key_with_pop_to_normal(pkpop: &amp;PublicKeyWithPoP): PublicKey &#123;
    PublicKey &#123;
        bytes: pkpop.bytes
    &#125;
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_public_key_with_pop_to_bytes"></a>

## Function `public_key_with_pop_to_bytes`

Serializes a PoP'd public key into 48 bytes.


<pre><code>public fun public_key_with_pop_to_bytes(pk: &amp;bls12381::PublicKeyWithPoP): vector&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun public_key_with_pop_to_bytes(pk: &amp;PublicKeyWithPoP): vector&lt;u8&gt; &#123;
    pk.bytes
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_signature_from_bytes"></a>

## Function `signature_from_bytes`

Creates a new signature from a sequence of bytes. Does not check the signature for prime-order subgroup
membership since that is done implicitly during verification.


<pre><code>public fun signature_from_bytes(bytes: vector&lt;u8&gt;): bls12381::Signature
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun signature_from_bytes(bytes: vector&lt;u8&gt;): Signature &#123;
    Signature &#123;
        bytes
    &#125;
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_signature_to_bytes"></a>

## Function `signature_to_bytes`

Serializes the signature into 96 bytes.


<pre><code>public fun signature_to_bytes(sig: &amp;bls12381::Signature): vector&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun signature_to_bytes(sig: &amp;Signature): vector&lt;u8&gt; &#123;
    sig.bytes
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_signature_subgroup_check"></a>

## Function `signature_subgroup_check`

Checks that the group element that defines a signature is in the prime-order subgroup.
This check is implicitly performed when verifying any signature via this module, but we expose this functionality
in case it might be useful for applications to easily dismiss invalid signatures early on.


<pre><code>public fun signature_subgroup_check(signature: &amp;bls12381::Signature): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun signature_subgroup_check(signature: &amp;Signature): bool &#123;
    signature_subgroup_check_internal(signature.bytes)
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_aggregate_pubkeys"></a>

## Function `aggregate_pubkeys`

Given a vector of public keys with verified PoPs, combines them into an *aggregated* public key which can be used
to verify multisignatures using <code>verify_multisignature</code> and aggregate signatures using <code>verify_aggregate_signature</code>.
Aborts if no public keys are given as input.


<pre><code>public fun aggregate_pubkeys(public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;): bls12381::AggrPublicKeysWithPoP
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun aggregate_pubkeys(public_keys: vector&lt;PublicKeyWithPoP&gt;): AggrPublicKeysWithPoP &#123;
    let (bytes, success) &#61; aggregate_pubkeys_internal(public_keys);
    assert!(success, std::error::invalid_argument(EZERO_PUBKEYS));

    AggrPublicKeysWithPoP &#123;
        bytes
    &#125;
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_aggregate_pubkey_to_bytes"></a>

## Function `aggregate_pubkey_to_bytes`

Serializes an aggregate public key into 48 bytes.


<pre><code>public fun aggregate_pubkey_to_bytes(apk: &amp;bls12381::AggrPublicKeysWithPoP): vector&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun aggregate_pubkey_to_bytes(apk: &amp;AggrPublicKeysWithPoP): vector&lt;u8&gt; &#123;
    apk.bytes
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_aggregate_signatures"></a>

## Function `aggregate_signatures`

Aggregates the input signatures into an aggregate-or-multi-signature structure, which can be later verified via
<code>verify_aggregate_signature</code> or <code>verify_multisignature</code>. Returns <code>None</code> if zero signatures are given as input
or if some of the signatures are not valid group elements.


<pre><code>public fun aggregate_signatures(signatures: vector&lt;bls12381::Signature&gt;): option::Option&lt;bls12381::AggrOrMultiSignature&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun aggregate_signatures(signatures: vector&lt;Signature&gt;): Option&lt;AggrOrMultiSignature&gt; &#123;
    let (bytes, success) &#61; aggregate_signatures_internal(signatures);
    if (success) &#123;
        option::some(
            AggrOrMultiSignature &#123;
                bytes
            &#125;
        )
    &#125; else &#123;
        option::none&lt;AggrOrMultiSignature&gt;()
    &#125;
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_aggr_or_multi_signature_to_bytes"></a>

## Function `aggr_or_multi_signature_to_bytes`

Serializes an aggregate-or-multi-signature into 96 bytes.


<pre><code>public fun aggr_or_multi_signature_to_bytes(sig: &amp;bls12381::AggrOrMultiSignature): vector&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun aggr_or_multi_signature_to_bytes(sig: &amp;AggrOrMultiSignature): vector&lt;u8&gt; &#123;
    sig.bytes
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_aggr_or_multi_signature_from_bytes"></a>

## Function `aggr_or_multi_signature_from_bytes`

Deserializes an aggregate-or-multi-signature from 96 bytes.


<pre><code>public fun aggr_or_multi_signature_from_bytes(bytes: vector&lt;u8&gt;): bls12381::AggrOrMultiSignature
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun aggr_or_multi_signature_from_bytes(bytes: vector&lt;u8&gt;): AggrOrMultiSignature &#123;
    assert!(std::vector::length(&amp;bytes) &#61;&#61; SIGNATURE_SIZE, std::error::invalid_argument(EWRONG_SIZE));

    AggrOrMultiSignature &#123;
        bytes
    &#125;
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_aggr_or_multi_signature_subgroup_check"></a>

## Function `aggr_or_multi_signature_subgroup_check`

Checks that the group element that defines an aggregate-or-multi-signature is in the prime-order subgroup.


<pre><code>public fun aggr_or_multi_signature_subgroup_check(signature: &amp;bls12381::AggrOrMultiSignature): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun aggr_or_multi_signature_subgroup_check(signature: &amp;AggrOrMultiSignature): bool &#123;
    signature_subgroup_check_internal(signature.bytes)
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_verify_aggregate_signature"></a>

## Function `verify_aggregate_signature`

Verifies an aggregate signature, an aggregation of many signatures <code>s_i</code>, each on a different message <code>m_i</code>.


<pre><code>public fun verify_aggregate_signature(aggr_sig: &amp;bls12381::AggrOrMultiSignature, public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;, messages: vector&lt;vector&lt;u8&gt;&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun verify_aggregate_signature(
    aggr_sig: &amp;AggrOrMultiSignature,
    public_keys: vector&lt;PublicKeyWithPoP&gt;,
    messages: vector&lt;vector&lt;u8&gt;&gt;,
): bool &#123;
    verify_aggregate_signature_internal(aggr_sig.bytes, public_keys, messages)
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_verify_multisignature"></a>

## Function `verify_multisignature`

Verifies a multisignature: an aggregation of many signatures, each on the same message <code>m</code>.


<pre><code>public fun verify_multisignature(multisig: &amp;bls12381::AggrOrMultiSignature, aggr_public_key: &amp;bls12381::AggrPublicKeysWithPoP, message: vector&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun verify_multisignature(
    multisig: &amp;AggrOrMultiSignature,
    aggr_public_key: &amp;AggrPublicKeysWithPoP,
    message: vector&lt;u8&gt;
): bool &#123;
    verify_multisignature_internal(multisig.bytes, aggr_public_key.bytes, message)
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_verify_normal_signature"></a>

## Function `verify_normal_signature`

Verifies a normal, non-aggregated signature.


<pre><code>public fun verify_normal_signature(signature: &amp;bls12381::Signature, public_key: &amp;bls12381::PublicKey, message: vector&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun verify_normal_signature(
    signature: &amp;Signature,
    public_key: &amp;PublicKey,
    message: vector&lt;u8&gt;
): bool &#123;
    verify_normal_signature_internal(signature.bytes, public_key.bytes, message)
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_verify_signature_share"></a>

## Function `verify_signature_share`

Verifies a signature share in the multisignature share or an aggregate signature share.


<pre><code>public fun verify_signature_share(signature_share: &amp;bls12381::Signature, public_key: &amp;bls12381::PublicKeyWithPoP, message: vector&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun verify_signature_share(
    signature_share: &amp;Signature,
    public_key: &amp;PublicKeyWithPoP,
    message: vector&lt;u8&gt;
): bool &#123;
    verify_signature_share_internal(signature_share.bytes, public_key.bytes, message)
&#125;
</code></pre>



</details>

<a id="0x1_bls12381_aggregate_pubkeys_internal"></a>

## Function `aggregate_pubkeys_internal`

CRYPTOGRAPHY WARNING: This function assumes that the caller verified all public keys have a valid
proof-of-possesion (PoP) using <code>verify_proof_of_possession</code>.

Given a vector of serialized public keys, combines them into an aggregated public key, returning <code>(bytes, true)</code>,
where <code>bytes</code> store the serialized public key.
Aborts if no public keys are given as input.


<pre><code>fun aggregate_pubkeys_internal(public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;): (vector&lt;u8&gt;, bool)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun aggregate_pubkeys_internal(public_keys: vector&lt;PublicKeyWithPoP&gt;): (vector&lt;u8&gt;, bool);
</code></pre>



</details>

<a id="0x1_bls12381_aggregate_signatures_internal"></a>

## Function `aggregate_signatures_internal`

CRYPTOGRAPHY WARNING: This function can be safely called without verifying that the input signatures are elements
of the prime-order subgroup of the BLS12-381 curve.

Given a vector of serialized signatures, combines them into an aggregate signature, returning <code>(bytes, true)</code>,
where <code>bytes</code> store the serialized signature.
Does not check the input signatures nor the final aggregated signatures for prime-order subgroup membership.
Returns <code>(_, false)</code> if no signatures are given as input.
Does not abort.


<pre><code>fun aggregate_signatures_internal(signatures: vector&lt;bls12381::Signature&gt;): (vector&lt;u8&gt;, bool)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun aggregate_signatures_internal(signatures: vector&lt;Signature&gt;): (vector&lt;u8&gt;, bool);
</code></pre>



</details>

<a id="0x1_bls12381_validate_pubkey_internal"></a>

## Function `validate_pubkey_internal`

Return <code>true</code> if the bytes in <code>public_key</code> are a valid BLS12-381 public key:
(1) it is NOT the identity point, and
(2) it is a BLS12-381 elliptic curve point, and
(3) it is a prime-order point
Return <code>false</code> otherwise.
Does not abort.


<pre><code>fun validate_pubkey_internal(public_key: vector&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun validate_pubkey_internal(public_key: vector&lt;u8&gt;): bool;
</code></pre>



</details>

<a id="0x1_bls12381_signature_subgroup_check_internal"></a>

## Function `signature_subgroup_check_internal`

Return <code>true</code> if the elliptic curve point serialized in <code>signature</code>:
(1) is NOT the identity point, and
(2) is a BLS12-381 elliptic curve point, and
(3) is a prime-order point
Return <code>false</code> otherwise.
Does not abort.


<pre><code>fun signature_subgroup_check_internal(signature: vector&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun signature_subgroup_check_internal(signature: vector&lt;u8&gt;): bool;
</code></pre>



</details>

<a id="0x1_bls12381_verify_aggregate_signature_internal"></a>

## Function `verify_aggregate_signature_internal`

CRYPTOGRAPHY WARNING: First, this function assumes all public keys have a valid proof-of-possesion (PoP).
This prevents both small-subgroup attacks and rogue-key attacks. Second, this function can be safely called
without verifying that the aggregate signature is in the prime-order subgroup of the BLS12-381 curve.

Returns <code>true</code> if the aggregate signature <code>aggsig</code> on <code>messages</code> under <code>public_keys</code> verifies (where <code>messages[i]</code>
should be signed by <code>public_keys[i]</code>).

Returns <code>false</code> if either:
- no public keys or messages are given as input,
- number of messages does not equal number of public keys
- <code>aggsig</code> (1) is the identity point, or (2) is NOT a BLS12-381 elliptic curve point, or (3) is NOT a
prime-order point
Does not abort.


<pre><code>fun verify_aggregate_signature_internal(aggsig: vector&lt;u8&gt;, public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;, messages: vector&lt;vector&lt;u8&gt;&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun verify_aggregate_signature_internal(
    aggsig: vector&lt;u8&gt;,
    public_keys: vector&lt;PublicKeyWithPoP&gt;,
    messages: vector&lt;vector&lt;u8&gt;&gt;,
): bool;
</code></pre>



</details>

<a id="0x1_bls12381_verify_multisignature_internal"></a>

## Function `verify_multisignature_internal`

CRYPTOGRAPHY WARNING: This function assumes verified proofs-of-possesion (PoP) for the public keys used in
computing the aggregate public key. This prevents small-subgroup attacks and rogue-key attacks.

Return <code>true</code> if the BLS <code>multisignature</code> on <code>message</code> verifies against the BLS aggregate public key <code>agg_public_key</code>.
Returns <code>false</code> otherwise.
Does not abort.


<pre><code>fun verify_multisignature_internal(multisignature: vector&lt;u8&gt;, agg_public_key: vector&lt;u8&gt;, message: vector&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun verify_multisignature_internal(
    multisignature: vector&lt;u8&gt;,
    agg_public_key: vector&lt;u8&gt;,
    message: vector&lt;u8&gt;
): bool;
</code></pre>



</details>

<a id="0x1_bls12381_verify_normal_signature_internal"></a>

## Function `verify_normal_signature_internal`

CRYPTOGRAPHY WARNING: This function WILL check that the public key is a prime-order point, in order to prevent
library users from misusing the library by forgetting to validate public keys before giving them as arguments to
this function.

Returns <code>true</code> if the <code>signature</code> on <code>message</code> verifies under <code>public key</code>.
Returns <code>false</code> otherwise.
Does not abort.


<pre><code>fun verify_normal_signature_internal(signature: vector&lt;u8&gt;, public_key: vector&lt;u8&gt;, message: vector&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun verify_normal_signature_internal(
    signature: vector&lt;u8&gt;,
    public_key: vector&lt;u8&gt;,
    message: vector&lt;u8&gt;
): bool;
</code></pre>



</details>

<a id="0x1_bls12381_verify_proof_of_possession_internal"></a>

## Function `verify_proof_of_possession_internal`

Return <code>true</code> if the bytes in <code>public_key</code> are a valid bls12381 public key (as per <code>validate_pubkey</code>)
*and* this public key has a valid proof-of-possesion (PoP).
Return <code>false</code> otherwise.
Does not abort.


<pre><code>fun verify_proof_of_possession_internal(public_key: vector&lt;u8&gt;, proof_of_possesion: vector&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun verify_proof_of_possession_internal(
    public_key: vector&lt;u8&gt;,
    proof_of_possesion: vector&lt;u8&gt;
): bool;
</code></pre>



</details>

<a id="0x1_bls12381_verify_signature_share_internal"></a>

## Function `verify_signature_share_internal`

CRYPTOGRAPHY WARNING: Assumes the public key has a valid proof-of-possesion (PoP). This prevents rogue-key
attacks later on during signature aggregation.

Returns <code>true</code> if the <code>signature_share</code> on <code>message</code> verifies under <code>public key</code>.
Returns <code>false</code> otherwise, similar to <code>verify_multisignature</code>.
Does not abort.


<pre><code>fun verify_signature_share_internal(signature_share: vector&lt;u8&gt;, public_key: vector&lt;u8&gt;, message: vector&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun verify_signature_share_internal(
    signature_share: vector&lt;u8&gt;,
    public_key: vector&lt;u8&gt;,
    message: vector&lt;u8&gt;
): bool;
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_public_key_from_bytes"></a>

### Function `public_key_from_bytes`


<pre><code>public fun public_key_from_bytes(bytes: vector&lt;u8&gt;): option::Option&lt;bls12381::PublicKey&gt;
</code></pre>




<pre><code>aborts_if false;
ensures spec_validate_pubkey_internal(bytes) &#61;&#61;&gt; (std::option::spec_is_some(result) &amp;&amp; std::option::spec_borrow(result).bytes &#61;&#61; bytes);
ensures !spec_validate_pubkey_internal(bytes) &#61;&#61;&gt; std::option::spec_is_none(result);
</code></pre>



<a id="@Specification_1_public_key_from_bytes_with_pop"></a>

### Function `public_key_from_bytes_with_pop`


<pre><code>public fun public_key_from_bytes_with_pop(pk_bytes: vector&lt;u8&gt;, pop: &amp;bls12381::ProofOfPossession): option::Option&lt;bls12381::PublicKeyWithPoP&gt;
</code></pre>




<pre><code>pragma opaque;
aborts_if false;
ensures spec_verify_proof_of_possession_internal(pk_bytes, pop.bytes) &#61;&#61;&gt; (std::option::spec_is_some(result) &amp;&amp; std::option::spec_borrow(result).bytes &#61;&#61; pk_bytes);
ensures !spec_verify_proof_of_possession_internal(pk_bytes, pop.bytes) &#61;&#61;&gt; std::option::spec_is_none(result);
ensures [abstract] result &#61;&#61; spec_public_key_from_bytes_with_pop(pk_bytes, pop);
</code></pre>



<a id="@Specification_1_aggregate_pubkeys"></a>

### Function `aggregate_pubkeys`


<pre><code>public fun aggregate_pubkeys(public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;): bls12381::AggrPublicKeysWithPoP
</code></pre>




<pre><code>let bytes &#61; spec_aggregate_pubkeys_internal_1(public_keys);
let success &#61; spec_aggregate_pubkeys_internal_2(public_keys);
aborts_if !success;
ensures result.bytes &#61;&#61; bytes;
</code></pre>



<a id="@Specification_1_aggregate_signatures"></a>

### Function `aggregate_signatures`


<pre><code>public fun aggregate_signatures(signatures: vector&lt;bls12381::Signature&gt;): option::Option&lt;bls12381::AggrOrMultiSignature&gt;
</code></pre>




<pre><code>aborts_if false;
let bytes &#61; spec_aggregate_signatures_internal_1(signatures);
let success &#61; spec_aggregate_signatures_internal_2(signatures);
ensures success &#61;&#61;&gt; (std::option::spec_is_some(result) &amp;&amp; std::option::spec_borrow(result).bytes &#61;&#61; bytes);
ensures !success &#61;&#61;&gt; std::option::spec_is_none(result);
</code></pre>



<a id="@Specification_1_aggr_or_multi_signature_from_bytes"></a>

### Function `aggr_or_multi_signature_from_bytes`


<pre><code>public fun aggr_or_multi_signature_from_bytes(bytes: vector&lt;u8&gt;): bls12381::AggrOrMultiSignature
</code></pre>




<pre><code>aborts_if len(bytes) !&#61; SIGNATURE_SIZE;
ensures result.bytes &#61;&#61; bytes;
</code></pre>



<a id="@Specification_1_aggr_or_multi_signature_subgroup_check"></a>

### Function `aggr_or_multi_signature_subgroup_check`


<pre><code>public fun aggr_or_multi_signature_subgroup_check(signature: &amp;bls12381::AggrOrMultiSignature): bool
</code></pre>




<pre><code>aborts_if false;
ensures result &#61;&#61; spec_signature_subgroup_check_internal(signature.bytes);
</code></pre>



<a id="@Specification_1_verify_aggregate_signature"></a>

### Function `verify_aggregate_signature`


<pre><code>public fun verify_aggregate_signature(aggr_sig: &amp;bls12381::AggrOrMultiSignature, public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;, messages: vector&lt;vector&lt;u8&gt;&gt;): bool
</code></pre>




<pre><code>aborts_if false;
ensures result &#61;&#61; spec_verify_aggregate_signature_internal(aggr_sig.bytes, public_keys, messages);
</code></pre>



<a id="@Specification_1_verify_multisignature"></a>

### Function `verify_multisignature`


<pre><code>public fun verify_multisignature(multisig: &amp;bls12381::AggrOrMultiSignature, aggr_public_key: &amp;bls12381::AggrPublicKeysWithPoP, message: vector&lt;u8&gt;): bool
</code></pre>




<pre><code>aborts_if false;
ensures result &#61;&#61; spec_verify_multisignature_internal(multisig.bytes, aggr_public_key.bytes, message);
</code></pre>



<a id="@Specification_1_verify_normal_signature"></a>

### Function `verify_normal_signature`


<pre><code>public fun verify_normal_signature(signature: &amp;bls12381::Signature, public_key: &amp;bls12381::PublicKey, message: vector&lt;u8&gt;): bool
</code></pre>




<pre><code>aborts_if false;
ensures result &#61;&#61; spec_verify_normal_signature_internal(signature.bytes, public_key.bytes, message);
</code></pre>



<a id="@Specification_1_verify_signature_share"></a>

### Function `verify_signature_share`


<pre><code>public fun verify_signature_share(signature_share: &amp;bls12381::Signature, public_key: &amp;bls12381::PublicKeyWithPoP, message: vector&lt;u8&gt;): bool
</code></pre>




<pre><code>aborts_if false;
ensures result &#61;&#61; spec_verify_signature_share_internal(signature_share.bytes, public_key.bytes, message);
</code></pre>



<a id="@Specification_1_aggregate_pubkeys_internal"></a>

### Function `aggregate_pubkeys_internal`


<pre><code>fun aggregate_pubkeys_internal(public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;): (vector&lt;u8&gt;, bool)
</code></pre>




<pre><code>pragma opaque;
aborts_if [abstract] false;
ensures result_1 &#61;&#61; spec_aggregate_pubkeys_internal_1(public_keys);
ensures result_2 &#61;&#61; spec_aggregate_pubkeys_internal_2(public_keys);
</code></pre>



<a id="@Specification_1_aggregate_signatures_internal"></a>

### Function `aggregate_signatures_internal`


<pre><code>fun aggregate_signatures_internal(signatures: vector&lt;bls12381::Signature&gt;): (vector&lt;u8&gt;, bool)
</code></pre>




<pre><code>pragma opaque;
aborts_if [abstract] false;
ensures result_1 &#61;&#61; spec_aggregate_signatures_internal_1(signatures);
ensures result_2 &#61;&#61; spec_aggregate_signatures_internal_2(signatures);
</code></pre>



<a id="@Specification_1_validate_pubkey_internal"></a>

### Function `validate_pubkey_internal`


<pre><code>fun validate_pubkey_internal(public_key: vector&lt;u8&gt;): bool
</code></pre>




<pre><code>pragma opaque;
aborts_if [abstract] false;
ensures result &#61;&#61; spec_validate_pubkey_internal(public_key);
</code></pre>



<a id="@Specification_1_signature_subgroup_check_internal"></a>

### Function `signature_subgroup_check_internal`


<pre><code>fun signature_subgroup_check_internal(signature: vector&lt;u8&gt;): bool
</code></pre>




<pre><code>pragma opaque;
aborts_if [abstract] false;
ensures result &#61;&#61; spec_signature_subgroup_check_internal(signature);
</code></pre>



<a id="@Specification_1_verify_aggregate_signature_internal"></a>

### Function `verify_aggregate_signature_internal`


<pre><code>fun verify_aggregate_signature_internal(aggsig: vector&lt;u8&gt;, public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;, messages: vector&lt;vector&lt;u8&gt;&gt;): bool
</code></pre>




<pre><code>pragma opaque;
aborts_if [abstract] false;
ensures result &#61;&#61; spec_verify_aggregate_signature_internal(aggsig, public_keys, messages);
</code></pre>



<a id="@Specification_1_verify_multisignature_internal"></a>

### Function `verify_multisignature_internal`


<pre><code>fun verify_multisignature_internal(multisignature: vector&lt;u8&gt;, agg_public_key: vector&lt;u8&gt;, message: vector&lt;u8&gt;): bool
</code></pre>




<pre><code>pragma opaque;
aborts_if [abstract] false;
ensures result &#61;&#61; spec_verify_multisignature_internal(multisignature, agg_public_key, message);
</code></pre>



<a id="@Specification_1_verify_normal_signature_internal"></a>

### Function `verify_normal_signature_internal`


<pre><code>fun verify_normal_signature_internal(signature: vector&lt;u8&gt;, public_key: vector&lt;u8&gt;, message: vector&lt;u8&gt;): bool
</code></pre>




<pre><code>pragma opaque;
aborts_if [abstract] false;
ensures result &#61;&#61; spec_verify_normal_signature_internal(signature, public_key, message);
</code></pre>



<a id="@Specification_1_verify_proof_of_possession_internal"></a>

### Function `verify_proof_of_possession_internal`


<pre><code>fun verify_proof_of_possession_internal(public_key: vector&lt;u8&gt;, proof_of_possesion: vector&lt;u8&gt;): bool
</code></pre>




<pre><code>pragma opaque;
aborts_if [abstract] false;
ensures result &#61;&#61; spec_verify_proof_of_possession_internal(public_key, proof_of_possesion);
</code></pre>



<a id="@Specification_1_verify_signature_share_internal"></a>

### Function `verify_signature_share_internal`


<pre><code>fun verify_signature_share_internal(signature_share: vector&lt;u8&gt;, public_key: vector&lt;u8&gt;, message: vector&lt;u8&gt;): bool
</code></pre>




<pre><code>pragma opaque;
aborts_if [abstract] false;
ensures result &#61;&#61; spec_verify_signature_share_internal(signature_share, public_key, message);
</code></pre>



<a id="@Helper_functions_2"></a>

### Helper functions



<a id="0x1_bls12381_spec_aggregate_pubkeys_internal_1"></a>


<pre><code>fun spec_aggregate_pubkeys_internal_1(public_keys: vector&lt;PublicKeyWithPoP&gt;): vector&lt;u8&gt;;
</code></pre>




<a id="0x1_bls12381_spec_public_key_from_bytes_with_pop"></a>


<pre><code>fun spec_public_key_from_bytes_with_pop(pk_bytes: vector&lt;u8&gt;, pop: ProofOfPossession): Option&lt;PublicKeyWithPoP&gt;;
</code></pre>




<a id="0x1_bls12381_spec_aggregate_pubkeys_internal_2"></a>


<pre><code>fun spec_aggregate_pubkeys_internal_2(public_keys: vector&lt;PublicKeyWithPoP&gt;): bool;
</code></pre>




<a id="0x1_bls12381_spec_aggregate_signatures_internal_1"></a>


<pre><code>fun spec_aggregate_signatures_internal_1(signatures: vector&lt;Signature&gt;): vector&lt;u8&gt;;
</code></pre>




<a id="0x1_bls12381_spec_aggregate_signatures_internal_2"></a>


<pre><code>fun spec_aggregate_signatures_internal_2(signatures: vector&lt;Signature&gt;): bool;
</code></pre>




<a id="0x1_bls12381_spec_validate_pubkey_internal"></a>


<pre><code>fun spec_validate_pubkey_internal(public_key: vector&lt;u8&gt;): bool;
</code></pre>




<a id="0x1_bls12381_spec_signature_subgroup_check_internal"></a>


<pre><code>fun spec_signature_subgroup_check_internal(signature: vector&lt;u8&gt;): bool;
</code></pre>




<a id="0x1_bls12381_spec_verify_aggregate_signature_internal"></a>


<pre><code>fun spec_verify_aggregate_signature_internal(
   aggsig: vector&lt;u8&gt;,
   public_keys: vector&lt;PublicKeyWithPoP&gt;,
   messages: vector&lt;vector&lt;u8&gt;&gt;,
): bool;
</code></pre>




<a id="0x1_bls12381_spec_verify_multisignature_internal"></a>


<pre><code>fun spec_verify_multisignature_internal(
   multisignature: vector&lt;u8&gt;,
   agg_public_key: vector&lt;u8&gt;,
   message: vector&lt;u8&gt;
): bool;
</code></pre>




<a id="0x1_bls12381_spec_verify_normal_signature_internal"></a>


<pre><code>fun spec_verify_normal_signature_internal(
   signature: vector&lt;u8&gt;,
   public_key: vector&lt;u8&gt;,
   message: vector&lt;u8&gt;
): bool;
</code></pre>




<a id="0x1_bls12381_spec_verify_proof_of_possession_internal"></a>


<pre><code>fun spec_verify_proof_of_possession_internal(
   public_key: vector&lt;u8&gt;,
   proof_of_possesion: vector&lt;u8&gt;
): bool;
</code></pre>




<a id="0x1_bls12381_spec_verify_signature_share_internal"></a>


<pre><code>fun spec_verify_signature_share_internal(
   signature_share: vector&lt;u8&gt;,
   public_key: vector&lt;u8&gt;,
   message: vector&lt;u8&gt;
): bool;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY
