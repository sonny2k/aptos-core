
<a id="0x1_bls12381"></a>

# Module `0x1::bls12381`

Contains functions for:<br/><br/>     The minimum&#45;pubkey&#45;size variant of [Boneh&#45;Lynn&#45;Shacham (BLS) signatures](https://en.wikipedia.org/wiki/BLS_digital_signature),<br/>     where public keys are BLS12&#45;381 elliptic&#45;curve points in $\mathbb&#123;G&#125;_1$ and signatures are in $\mathbb&#123;G&#125;_2$,<br/>     as per the [IETF BLS draft standard](https://datatracker.ietf.org/doc/html/draft&#45;irtf&#45;cfrg&#45;bls&#45;signature&#35;section&#45;2.1).


-  [Struct `PublicKey`](#0x1_bls12381_PublicKey)
-  [Struct `ProofOfPossession`](#0x1_bls12381_ProofOfPossession)
-  [Struct `PublicKeyWithPoP`](#0x1_bls12381_PublicKeyWithPoP)
-  [Struct `AggrPublicKeysWithPoP`](#0x1_bls12381_AggrPublicKeysWithPoP)
-  [Struct `Signature`](#0x1_bls12381_Signature)
-  [Struct `AggrOrMultiSignature`](#0x1_bls12381_AggrOrMultiSignature)
-  [Constants](#@Constants_0)
-  [Function `public_key_from_bytes`](#0x1_bls12381_public_key_from_bytes)
-  [Function `public_key_to_bytes`](#0x1_bls12381_public_key_to_bytes)
-  [Function `proof_of_possession_from_bytes`](#0x1_bls12381_proof_of_possession_from_bytes)
-  [Function `proof_of_possession_to_bytes`](#0x1_bls12381_proof_of_possession_to_bytes)
-  [Function `public_key_from_bytes_with_pop`](#0x1_bls12381_public_key_from_bytes_with_pop)
-  [Function `public_key_with_pop_to_normal`](#0x1_bls12381_public_key_with_pop_to_normal)
-  [Function `public_key_with_pop_to_bytes`](#0x1_bls12381_public_key_with_pop_to_bytes)
-  [Function `signature_from_bytes`](#0x1_bls12381_signature_from_bytes)
-  [Function `signature_to_bytes`](#0x1_bls12381_signature_to_bytes)
-  [Function `signature_subgroup_check`](#0x1_bls12381_signature_subgroup_check)
-  [Function `aggregate_pubkeys`](#0x1_bls12381_aggregate_pubkeys)
-  [Function `aggregate_pubkey_to_bytes`](#0x1_bls12381_aggregate_pubkey_to_bytes)
-  [Function `aggregate_signatures`](#0x1_bls12381_aggregate_signatures)
-  [Function `aggr_or_multi_signature_to_bytes`](#0x1_bls12381_aggr_or_multi_signature_to_bytes)
-  [Function `aggr_or_multi_signature_from_bytes`](#0x1_bls12381_aggr_or_multi_signature_from_bytes)
-  [Function `aggr_or_multi_signature_subgroup_check`](#0x1_bls12381_aggr_or_multi_signature_subgroup_check)
-  [Function `verify_aggregate_signature`](#0x1_bls12381_verify_aggregate_signature)
-  [Function `verify_multisignature`](#0x1_bls12381_verify_multisignature)
-  [Function `verify_normal_signature`](#0x1_bls12381_verify_normal_signature)
-  [Function `verify_signature_share`](#0x1_bls12381_verify_signature_share)
-  [Function `aggregate_pubkeys_internal`](#0x1_bls12381_aggregate_pubkeys_internal)
-  [Function `aggregate_signatures_internal`](#0x1_bls12381_aggregate_signatures_internal)
-  [Function `validate_pubkey_internal`](#0x1_bls12381_validate_pubkey_internal)
-  [Function `signature_subgroup_check_internal`](#0x1_bls12381_signature_subgroup_check_internal)
-  [Function `verify_aggregate_signature_internal`](#0x1_bls12381_verify_aggregate_signature_internal)
-  [Function `verify_multisignature_internal`](#0x1_bls12381_verify_multisignature_internal)
-  [Function `verify_normal_signature_internal`](#0x1_bls12381_verify_normal_signature_internal)
-  [Function `verify_proof_of_possession_internal`](#0x1_bls12381_verify_proof_of_possession_internal)
-  [Function `verify_signature_share_internal`](#0x1_bls12381_verify_signature_share_internal)
-  [Specification](#@Specification_1)
    -  [Function `public_key_from_bytes`](#@Specification_1_public_key_from_bytes)
    -  [Function `public_key_from_bytes_with_pop`](#@Specification_1_public_key_from_bytes_with_pop)
    -  [Function `aggregate_pubkeys`](#@Specification_1_aggregate_pubkeys)
    -  [Function `aggregate_signatures`](#@Specification_1_aggregate_signatures)
    -  [Function `aggr_or_multi_signature_from_bytes`](#@Specification_1_aggr_or_multi_signature_from_bytes)
    -  [Function `aggr_or_multi_signature_subgroup_check`](#@Specification_1_aggr_or_multi_signature_subgroup_check)
    -  [Function `verify_aggregate_signature`](#@Specification_1_verify_aggregate_signature)
    -  [Function `verify_multisignature`](#@Specification_1_verify_multisignature)
    -  [Function `verify_normal_signature`](#@Specification_1_verify_normal_signature)
    -  [Function `verify_signature_share`](#@Specification_1_verify_signature_share)
    -  [Function `aggregate_pubkeys_internal`](#@Specification_1_aggregate_pubkeys_internal)
    -  [Function `aggregate_signatures_internal`](#@Specification_1_aggregate_signatures_internal)
    -  [Function `validate_pubkey_internal`](#@Specification_1_validate_pubkey_internal)
    -  [Function `signature_subgroup_check_internal`](#@Specification_1_signature_subgroup_check_internal)
    -  [Function `verify_aggregate_signature_internal`](#@Specification_1_verify_aggregate_signature_internal)
    -  [Function `verify_multisignature_internal`](#@Specification_1_verify_multisignature_internal)
    -  [Function `verify_normal_signature_internal`](#@Specification_1_verify_normal_signature_internal)
    -  [Function `verify_proof_of_possession_internal`](#@Specification_1_verify_proof_of_possession_internal)
    -  [Function `verify_signature_share_internal`](#@Specification_1_verify_signature_share_internal)


<pre><code>use 0x1::error;<br/>use 0x1::option;<br/></code></pre>



<a id="0x1_bls12381_PublicKey"></a>

## Struct `PublicKey`

A &#42;validated&#42; public key that:<br/>   (1) is a point in the prime&#45;order subgroup of the BLS12&#45;381 elliptic curve, and
(2) is not the identity point<br/><br/> This struct can be used to verify a normal (non&#45;aggregated) signature.<br/><br/> This struct can be combined with a ProofOfPossession struct in order to create a PublicKeyWithPop struct, which<br/> can be used to verify a multisignature.


<pre><code>struct PublicKey has copy, drop, store<br/></code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: vector&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_ProofOfPossession"></a>

## Struct `ProofOfPossession`

A proof&#45;of&#45;possession (PoP).<br/> Given such a struct and a PublicKey struct, one can construct a PublicKeyWithPoP (see below).


<pre><code>struct ProofOfPossession has copy, drop, store<br/></code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: vector&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_PublicKeyWithPoP"></a>

## Struct `PublicKeyWithPoP`

A &#42;validated&#42; public key that had a successfully&#45;verified proof&#45;of&#45;possession (PoP).<br/><br/> A vector of these structs can be either:<br/>   (1) used to verify an aggregate signature
(2) aggregated with other PublicKeyWithPoP structs into an AggrPublicKeysWithPoP, which in turn can be used<br/>       to verify a multisignature


<pre><code>struct PublicKeyWithPoP has copy, drop, store<br/></code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: vector&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_AggrPublicKeysWithPoP"></a>

## Struct `AggrPublicKeysWithPoP`

An aggregation of public keys with verified PoPs, which can be used to verify multisignatures.


<pre><code>struct AggrPublicKeysWithPoP has copy, drop, store<br/></code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: vector&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_Signature"></a>

## Struct `Signature`

A BLS signature. This can be either a:<br/>   (1) normal (non&#45;aggregated) signature
(2) signature share (for a multisignature or aggregate signature)


<pre><code>struct Signature has copy, drop, store<br/></code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: vector&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_AggrOrMultiSignature"></a>

## Struct `AggrOrMultiSignature`

An aggregation of BLS signatures. This can be either a:<br/>   (4) aggregated signature (i.e., an aggregation of signatures s_i, each on a message m_i)<br/>   (3) multisignature (i.e., an aggregation of signatures s_i, each on the same message m)<br/><br/> We distinguish between a Signature type and a AggrOrMultiSignature type to prevent developers from interchangeably<br/> calling <code>verify_multisignature</code> and <code>verify_signature_share</code> to verify both multisignatures and signature shares,<br/> which could create problems down the line.


<pre><code>struct AggrOrMultiSignature has copy, drop, store<br/></code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: vector&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_bls12381_EWRONG_SIZE"></a>

One of the given inputs has the wrong size.s


<pre><code>const EWRONG_SIZE: u64 &#61; 2;<br/></code></pre>



<a id="0x1_bls12381_EZERO_PUBKEYS"></a>

The caller was supposed to input one or more public keys.


<pre><code>const EZERO_PUBKEYS: u64 &#61; 1;<br/></code></pre>



<a id="0x1_bls12381_E_NUM_SIGNERS_MUST_EQ_NUM_MESSAGES"></a>

The number of signers does not match the number of messages to be signed.


<pre><code>const E_NUM_SIGNERS_MUST_EQ_NUM_MESSAGES: u64 &#61; 3;<br/></code></pre>



<a id="0x1_bls12381_PUBLIC_KEY_NUM_BYTES"></a>

The public key size, in bytes


<pre><code>const PUBLIC_KEY_NUM_BYTES: u64 &#61; 48;<br/></code></pre>



<a id="0x1_bls12381_RANDOM_PK"></a>

Random signature generated by running <code>cargo test &#45;&#45; bls12381_sample_signature &#45;&#45;nocapture &#45;&#45;include&#45;ignored</code> in <code>crates/aptos&#45;crypto</code>.<br/> The associated SK is 07416693b6b32c84abe45578728e2379f525729e5b94762435a31e65ecc728da.


<pre><code>const RANDOM_PK: vector&lt;u8&gt; &#61; [138, 83, 231, 174, 82, 112, 227, 231, 101, 205, 138, 64, 50, 194, 231, 124, 111, 126, 135, 164, 78, 187, 133, 191, 40, 164, 215, 134, 85, 101, 105, 143, 151, 83, 70, 113, 66, 98, 249, 228, 124, 111, 62, 13, 93, 149, 22, 96];<br/></code></pre>



<a id="0x1_bls12381_RANDOM_SIGNATURE"></a>

Random signature generated by running <code>cargo test &#45;&#45; bls12381_sample_signature &#45;&#45;nocapture &#45;&#45;include&#45;ignored</code> in <code>crates/aptos&#45;crypto</code>.<br/> The message signed is &quot;Hello Aptos!&quot; and the associated SK is 07416693b6b32c84abe45578728e2379f525729e5b94762435a31e65ecc728da.


<pre><code>const RANDOM_SIGNATURE: vector&lt;u8&gt; &#61; [160, 26, 101, 133, 79, 152, 125, 52, 52, 20, 155, 127, 8, 247, 7, 48, 227, 11, 36, 25, 132, 232, 113, 43, 194, 172, 168, 133, 214, 50, 170, 252, 237, 76, 63, 102, 18, 9, 222, 187, 107, 28, 134, 1, 50, 102, 35, 204, 22, 202, 47, 108, 158, 220, 83, 183, 184, 139, 116, 53, 251, 107, 5, 221, 236, 228, 24, 210, 195, 77, 198, 172, 162, 245, 161, 26, 121, 230, 119, 116, 88, 44, 20, 8, 74, 1, 220, 183, 130, 14, 76, 180, 186, 208, 234, 141];<br/></code></pre>



<a id="0x1_bls12381_SIGNATURE_SIZE"></a>

The signature size, in bytes


<pre><code>const SIGNATURE_SIZE: u64 &#61; 96;<br/></code></pre>



<a id="0x1_bls12381_public_key_from_bytes"></a>

## Function `public_key_from_bytes`

Creates a new public key from a sequence of bytes.


<pre><code>public fun public_key_from_bytes(bytes: vector&lt;u8&gt;): option::Option&lt;bls12381::PublicKey&gt;<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun public_key_from_bytes(bytes: vector&lt;u8&gt;): Option&lt;PublicKey&gt; &#123;<br/>    if (validate_pubkey_internal(bytes)) &#123;<br/>        option::some(PublicKey &#123;<br/>            bytes<br/>        &#125;)<br/>    &#125; else &#123;<br/>        option::none&lt;PublicKey&gt;()<br/>    &#125;<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_public_key_to_bytes"></a>

## Function `public_key_to_bytes`

Serializes a public key into 48 bytes.


<pre><code>public fun public_key_to_bytes(pk: &amp;bls12381::PublicKey): vector&lt;u8&gt;<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun public_key_to_bytes(pk: &amp;PublicKey): vector&lt;u8&gt; &#123;<br/>    pk.bytes<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_proof_of_possession_from_bytes"></a>

## Function `proof_of_possession_from_bytes`

Creates a new proof&#45;of&#45;possession (PoP) which can be later used to create a PublicKeyWithPoP struct,


<pre><code>public fun proof_of_possession_from_bytes(bytes: vector&lt;u8&gt;): bls12381::ProofOfPossession<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun proof_of_possession_from_bytes(bytes: vector&lt;u8&gt;): ProofOfPossession &#123;<br/>    ProofOfPossession &#123;<br/>        bytes<br/>    &#125;<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_proof_of_possession_to_bytes"></a>

## Function `proof_of_possession_to_bytes`

Serializes the signature into 96 bytes.


<pre><code>public fun proof_of_possession_to_bytes(pop: &amp;bls12381::ProofOfPossession): vector&lt;u8&gt;<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun proof_of_possession_to_bytes(pop: &amp;ProofOfPossession): vector&lt;u8&gt; &#123;<br/>    pop.bytes<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_public_key_from_bytes_with_pop"></a>

## Function `public_key_from_bytes_with_pop`

Creates a PoP&apos;d public key from a normal public key and a corresponding proof&#45;of&#45;possession.


<pre><code>public fun public_key_from_bytes_with_pop(pk_bytes: vector&lt;u8&gt;, pop: &amp;bls12381::ProofOfPossession): option::Option&lt;bls12381::PublicKeyWithPoP&gt;<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun public_key_from_bytes_with_pop(pk_bytes: vector&lt;u8&gt;, pop: &amp;ProofOfPossession): Option&lt;PublicKeyWithPoP&gt; &#123;<br/>    if (verify_proof_of_possession_internal(pk_bytes, pop.bytes)) &#123;<br/>        option::some(PublicKeyWithPoP &#123;<br/>            bytes: pk_bytes<br/>        &#125;)<br/>    &#125; else &#123;<br/>        option::none&lt;PublicKeyWithPoP&gt;()<br/>    &#125;<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_public_key_with_pop_to_normal"></a>

## Function `public_key_with_pop_to_normal`

Creates a normal public key from a PoP&apos;d public key.


<pre><code>public fun public_key_with_pop_to_normal(pkpop: &amp;bls12381::PublicKeyWithPoP): bls12381::PublicKey<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun public_key_with_pop_to_normal(pkpop: &amp;PublicKeyWithPoP): PublicKey &#123;<br/>    PublicKey &#123;<br/>        bytes: pkpop.bytes<br/>    &#125;<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_public_key_with_pop_to_bytes"></a>

## Function `public_key_with_pop_to_bytes`

Serializes a PoP&apos;d public key into 48 bytes.


<pre><code>public fun public_key_with_pop_to_bytes(pk: &amp;bls12381::PublicKeyWithPoP): vector&lt;u8&gt;<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun public_key_with_pop_to_bytes(pk: &amp;PublicKeyWithPoP): vector&lt;u8&gt; &#123;<br/>    pk.bytes<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_signature_from_bytes"></a>

## Function `signature_from_bytes`

Creates a new signature from a sequence of bytes. Does not check the signature for prime&#45;order subgroup<br/> membership since that is done implicitly during verification.


<pre><code>public fun signature_from_bytes(bytes: vector&lt;u8&gt;): bls12381::Signature<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun signature_from_bytes(bytes: vector&lt;u8&gt;): Signature &#123;<br/>    Signature &#123;<br/>        bytes<br/>    &#125;<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_signature_to_bytes"></a>

## Function `signature_to_bytes`

Serializes the signature into 96 bytes.


<pre><code>public fun signature_to_bytes(sig: &amp;bls12381::Signature): vector&lt;u8&gt;<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun signature_to_bytes(sig: &amp;Signature): vector&lt;u8&gt; &#123;<br/>    sig.bytes<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_signature_subgroup_check"></a>

## Function `signature_subgroup_check`

Checks that the group element that defines a signature is in the prime&#45;order subgroup.<br/> This check is implicitly performed when verifying any signature via this module, but we expose this functionality<br/> in case it might be useful for applications to easily dismiss invalid signatures early on.


<pre><code>public fun signature_subgroup_check(signature: &amp;bls12381::Signature): bool<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun signature_subgroup_check(signature: &amp;Signature): bool &#123;<br/>    signature_subgroup_check_internal(signature.bytes)<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_aggregate_pubkeys"></a>

## Function `aggregate_pubkeys`

Given a vector of public keys with verified PoPs, combines them into an &#42;aggregated&#42; public key which can be used<br/> to verify multisignatures using <code>verify_multisignature</code> and aggregate signatures using <code>verify_aggregate_signature</code>.<br/> Aborts if no public keys are given as input.


<pre><code>public fun aggregate_pubkeys(public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;): bls12381::AggrPublicKeysWithPoP<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun aggregate_pubkeys(public_keys: vector&lt;PublicKeyWithPoP&gt;): AggrPublicKeysWithPoP &#123;<br/>    let (bytes, success) &#61; aggregate_pubkeys_internal(public_keys);<br/>    assert!(success, std::error::invalid_argument(EZERO_PUBKEYS));<br/><br/>    AggrPublicKeysWithPoP &#123;<br/>        bytes<br/>    &#125;<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_aggregate_pubkey_to_bytes"></a>

## Function `aggregate_pubkey_to_bytes`

Serializes an aggregate public key into 48 bytes.


<pre><code>public fun aggregate_pubkey_to_bytes(apk: &amp;bls12381::AggrPublicKeysWithPoP): vector&lt;u8&gt;<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun aggregate_pubkey_to_bytes(apk: &amp;AggrPublicKeysWithPoP): vector&lt;u8&gt; &#123;<br/>    apk.bytes<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_aggregate_signatures"></a>

## Function `aggregate_signatures`

Aggregates the input signatures into an aggregate&#45;or&#45;multi&#45;signature structure, which can be later verified via<br/> <code>verify_aggregate_signature</code> or <code>verify_multisignature</code>. Returns <code>None</code> if zero signatures are given as input<br/> or if some of the signatures are not valid group elements.


<pre><code>public fun aggregate_signatures(signatures: vector&lt;bls12381::Signature&gt;): option::Option&lt;bls12381::AggrOrMultiSignature&gt;<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun aggregate_signatures(signatures: vector&lt;Signature&gt;): Option&lt;AggrOrMultiSignature&gt; &#123;<br/>    let (bytes, success) &#61; aggregate_signatures_internal(signatures);<br/>    if (success) &#123;<br/>        option::some(<br/>            AggrOrMultiSignature &#123;<br/>                bytes<br/>            &#125;<br/>        )<br/>    &#125; else &#123;<br/>        option::none&lt;AggrOrMultiSignature&gt;()<br/>    &#125;<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_aggr_or_multi_signature_to_bytes"></a>

## Function `aggr_or_multi_signature_to_bytes`

Serializes an aggregate&#45;or&#45;multi&#45;signature into 96 bytes.


<pre><code>public fun aggr_or_multi_signature_to_bytes(sig: &amp;bls12381::AggrOrMultiSignature): vector&lt;u8&gt;<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun aggr_or_multi_signature_to_bytes(sig: &amp;AggrOrMultiSignature): vector&lt;u8&gt; &#123;<br/>    sig.bytes<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_aggr_or_multi_signature_from_bytes"></a>

## Function `aggr_or_multi_signature_from_bytes`

Deserializes an aggregate&#45;or&#45;multi&#45;signature from 96 bytes.


<pre><code>public fun aggr_or_multi_signature_from_bytes(bytes: vector&lt;u8&gt;): bls12381::AggrOrMultiSignature<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun aggr_or_multi_signature_from_bytes(bytes: vector&lt;u8&gt;): AggrOrMultiSignature &#123;<br/>    assert!(std::vector::length(&amp;bytes) &#61;&#61; SIGNATURE_SIZE, std::error::invalid_argument(EWRONG_SIZE));<br/><br/>    AggrOrMultiSignature &#123;<br/>        bytes<br/>    &#125;<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_aggr_or_multi_signature_subgroup_check"></a>

## Function `aggr_or_multi_signature_subgroup_check`

Checks that the group element that defines an aggregate&#45;or&#45;multi&#45;signature is in the prime&#45;order subgroup.


<pre><code>public fun aggr_or_multi_signature_subgroup_check(signature: &amp;bls12381::AggrOrMultiSignature): bool<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun aggr_or_multi_signature_subgroup_check(signature: &amp;AggrOrMultiSignature): bool &#123;<br/>    signature_subgroup_check_internal(signature.bytes)<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_verify_aggregate_signature"></a>

## Function `verify_aggregate_signature`

Verifies an aggregate signature, an aggregation of many signatures <code>s_i</code>, each on a different message <code>m_i</code>.


<pre><code>public fun verify_aggregate_signature(aggr_sig: &amp;bls12381::AggrOrMultiSignature, public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;, messages: vector&lt;vector&lt;u8&gt;&gt;): bool<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun verify_aggregate_signature(<br/>    aggr_sig: &amp;AggrOrMultiSignature,<br/>    public_keys: vector&lt;PublicKeyWithPoP&gt;,<br/>    messages: vector&lt;vector&lt;u8&gt;&gt;,<br/>): bool &#123;<br/>    verify_aggregate_signature_internal(aggr_sig.bytes, public_keys, messages)<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_verify_multisignature"></a>

## Function `verify_multisignature`

Verifies a multisignature: an aggregation of many signatures, each on the same message <code>m</code>.


<pre><code>public fun verify_multisignature(multisig: &amp;bls12381::AggrOrMultiSignature, aggr_public_key: &amp;bls12381::AggrPublicKeysWithPoP, message: vector&lt;u8&gt;): bool<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun verify_multisignature(<br/>    multisig: &amp;AggrOrMultiSignature,<br/>    aggr_public_key: &amp;AggrPublicKeysWithPoP,<br/>    message: vector&lt;u8&gt;<br/>): bool &#123;<br/>    verify_multisignature_internal(multisig.bytes, aggr_public_key.bytes, message)<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_verify_normal_signature"></a>

## Function `verify_normal_signature`

Verifies a normal, non&#45;aggregated signature.


<pre><code>public fun verify_normal_signature(signature: &amp;bls12381::Signature, public_key: &amp;bls12381::PublicKey, message: vector&lt;u8&gt;): bool<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun verify_normal_signature(<br/>    signature: &amp;Signature,<br/>    public_key: &amp;PublicKey,<br/>    message: vector&lt;u8&gt;<br/>): bool &#123;<br/>    verify_normal_signature_internal(signature.bytes, public_key.bytes, message)<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_verify_signature_share"></a>

## Function `verify_signature_share`

Verifies a signature share in the multisignature share or an aggregate signature share.


<pre><code>public fun verify_signature_share(signature_share: &amp;bls12381::Signature, public_key: &amp;bls12381::PublicKeyWithPoP, message: vector&lt;u8&gt;): bool<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>public fun verify_signature_share(<br/>    signature_share: &amp;Signature,<br/>    public_key: &amp;PublicKeyWithPoP,<br/>    message: vector&lt;u8&gt;<br/>): bool &#123;<br/>    verify_signature_share_internal(signature_share.bytes, public_key.bytes, message)<br/>&#125;<br/></code></pre>



</details>

<a id="0x1_bls12381_aggregate_pubkeys_internal"></a>

## Function `aggregate_pubkeys_internal`

CRYPTOGRAPHY WARNING: This function assumes that the caller verified all public keys have a valid<br/> proof&#45;of&#45;possesion (PoP) using <code>verify_proof_of_possession</code>.<br/><br/> Given a vector of serialized public keys, combines them into an aggregated public key, returning <code>(bytes, true)</code>,<br/> where <code>bytes</code> store the serialized public key.<br/> Aborts if no public keys are given as input.


<pre><code>fun aggregate_pubkeys_internal(public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;): (vector&lt;u8&gt;, bool)<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun aggregate_pubkeys_internal(public_keys: vector&lt;PublicKeyWithPoP&gt;): (vector&lt;u8&gt;, bool);<br/></code></pre>



</details>

<a id="0x1_bls12381_aggregate_signatures_internal"></a>

## Function `aggregate_signatures_internal`

CRYPTOGRAPHY WARNING: This function can be safely called without verifying that the input signatures are elements<br/> of the prime&#45;order subgroup of the BLS12&#45;381 curve.<br/><br/> Given a vector of serialized signatures, combines them into an aggregate signature, returning <code>(bytes, true)</code>,<br/> where <code>bytes</code> store the serialized signature.<br/> Does not check the input signatures nor the final aggregated signatures for prime&#45;order subgroup membership.<br/> Returns <code>(_, false)</code> if no signatures are given as input.<br/> Does not abort.


<pre><code>fun aggregate_signatures_internal(signatures: vector&lt;bls12381::Signature&gt;): (vector&lt;u8&gt;, bool)<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun aggregate_signatures_internal(signatures: vector&lt;Signature&gt;): (vector&lt;u8&gt;, bool);<br/></code></pre>



</details>

<a id="0x1_bls12381_validate_pubkey_internal"></a>

## Function `validate_pubkey_internal`

Return <code>true</code> if the bytes in <code>public_key</code> are a valid BLS12&#45;381 public key:<br/>  (1) it is NOT the identity point, and
(2) it is a BLS12&#45;381 elliptic curve point, and
(3) it is a prime&#45;order point<br/> Return <code>false</code> otherwise.<br/> Does not abort.


<pre><code>fun validate_pubkey_internal(public_key: vector&lt;u8&gt;): bool<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun validate_pubkey_internal(public_key: vector&lt;u8&gt;): bool;<br/></code></pre>



</details>

<a id="0x1_bls12381_signature_subgroup_check_internal"></a>

## Function `signature_subgroup_check_internal`

Return <code>true</code> if the elliptic curve point serialized in <code>signature</code>:<br/>  (1) is NOT the identity point, and
(2) is a BLS12&#45;381 elliptic curve point, and
(3) is a prime&#45;order point<br/> Return <code>false</code> otherwise.<br/> Does not abort.


<pre><code>fun signature_subgroup_check_internal(signature: vector&lt;u8&gt;): bool<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun signature_subgroup_check_internal(signature: vector&lt;u8&gt;): bool;<br/></code></pre>



</details>

<a id="0x1_bls12381_verify_aggregate_signature_internal"></a>

## Function `verify_aggregate_signature_internal`

CRYPTOGRAPHY WARNING: First, this function assumes all public keys have a valid proof&#45;of&#45;possesion (PoP).<br/> This prevents both small&#45;subgroup attacks and rogue&#45;key attacks. Second, this function can be safely called<br/> without verifying that the aggregate signature is in the prime&#45;order subgroup of the BLS12&#45;381 curve.<br/><br/> Returns <code>true</code> if the aggregate signature <code>aggsig</code> on <code>messages</code> under <code>public_keys</code> verifies (where <code>messages[i]</code><br/> should be signed by <code>public_keys[i]</code>).<br/><br/> Returns <code>false</code> if either:<br/> &#45; no public keys or messages are given as input,<br/> &#45; number of messages does not equal number of public keys<br/> &#45; <code>aggsig</code> (1) is the identity point, or (2) is NOT a BLS12&#45;381 elliptic curve point, or (3) is NOT a<br/>   prime&#45;order point<br/> Does not abort.


<pre><code>fun verify_aggregate_signature_internal(aggsig: vector&lt;u8&gt;, public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;, messages: vector&lt;vector&lt;u8&gt;&gt;): bool<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun verify_aggregate_signature_internal(<br/>    aggsig: vector&lt;u8&gt;,<br/>    public_keys: vector&lt;PublicKeyWithPoP&gt;,<br/>    messages: vector&lt;vector&lt;u8&gt;&gt;,<br/>): bool;<br/></code></pre>



</details>

<a id="0x1_bls12381_verify_multisignature_internal"></a>

## Function `verify_multisignature_internal`

CRYPTOGRAPHY WARNING: This function assumes verified proofs&#45;of&#45;possesion (PoP) for the public keys used in<br/> computing the aggregate public key. This prevents small&#45;subgroup attacks and rogue&#45;key attacks.<br/><br/> Return <code>true</code> if the BLS <code>multisignature</code> on <code>message</code> verifies against the BLS aggregate public key <code>agg_public_key</code>.<br/> Returns <code>false</code> otherwise.<br/> Does not abort.


<pre><code>fun verify_multisignature_internal(multisignature: vector&lt;u8&gt;, agg_public_key: vector&lt;u8&gt;, message: vector&lt;u8&gt;): bool<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun verify_multisignature_internal(<br/>    multisignature: vector&lt;u8&gt;,<br/>    agg_public_key: vector&lt;u8&gt;,<br/>    message: vector&lt;u8&gt;<br/>): bool;<br/></code></pre>



</details>

<a id="0x1_bls12381_verify_normal_signature_internal"></a>

## Function `verify_normal_signature_internal`

CRYPTOGRAPHY WARNING: This function WILL check that the public key is a prime&#45;order point, in order to prevent<br/> library users from misusing the library by forgetting to validate public keys before giving them as arguments to<br/> this function.<br/><br/> Returns <code>true</code> if the <code>signature</code> on <code>message</code> verifies under <code>public key</code>.<br/> Returns <code>false</code> otherwise.<br/> Does not abort.


<pre><code>fun verify_normal_signature_internal(signature: vector&lt;u8&gt;, public_key: vector&lt;u8&gt;, message: vector&lt;u8&gt;): bool<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun verify_normal_signature_internal(<br/>    signature: vector&lt;u8&gt;,<br/>    public_key: vector&lt;u8&gt;,<br/>    message: vector&lt;u8&gt;<br/>): bool;<br/></code></pre>



</details>

<a id="0x1_bls12381_verify_proof_of_possession_internal"></a>

## Function `verify_proof_of_possession_internal`

Return <code>true</code> if the bytes in <code>public_key</code> are a valid bls12381 public key (as per <code>validate_pubkey</code>)<br/> &#42;and&#42; this public key has a valid proof&#45;of&#45;possesion (PoP).<br/> Return <code>false</code> otherwise.<br/> Does not abort.


<pre><code>fun verify_proof_of_possession_internal(public_key: vector&lt;u8&gt;, proof_of_possesion: vector&lt;u8&gt;): bool<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun verify_proof_of_possession_internal(<br/>    public_key: vector&lt;u8&gt;,<br/>    proof_of_possesion: vector&lt;u8&gt;<br/>): bool;<br/></code></pre>



</details>

<a id="0x1_bls12381_verify_signature_share_internal"></a>

## Function `verify_signature_share_internal`

CRYPTOGRAPHY WARNING: Assumes the public key has a valid proof&#45;of&#45;possesion (PoP). This prevents rogue&#45;key<br/> attacks later on during signature aggregation.<br/><br/> Returns <code>true</code> if the <code>signature_share</code> on <code>message</code> verifies under <code>public key</code>.<br/> Returns <code>false</code> otherwise, similar to <code>verify_multisignature</code>.<br/> Does not abort.


<pre><code>fun verify_signature_share_internal(signature_share: vector&lt;u8&gt;, public_key: vector&lt;u8&gt;, message: vector&lt;u8&gt;): bool<br/></code></pre>



<details>
<summary>Implementation</summary>


<pre><code>native fun verify_signature_share_internal(<br/>    signature_share: vector&lt;u8&gt;,<br/>    public_key: vector&lt;u8&gt;,<br/>    message: vector&lt;u8&gt;<br/>): bool;<br/></code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_public_key_from_bytes"></a>

### Function `public_key_from_bytes`


<pre><code>public fun public_key_from_bytes(bytes: vector&lt;u8&gt;): option::Option&lt;bls12381::PublicKey&gt;<br/></code></pre>




<pre><code>aborts_if false;<br/>ensures spec_validate_pubkey_internal(bytes) &#61;&#61;&gt; (std::option::spec_is_some(result) &amp;&amp; std::option::spec_borrow(result).bytes &#61;&#61; bytes);<br/>ensures !spec_validate_pubkey_internal(bytes) &#61;&#61;&gt; std::option::spec_is_none(result);<br/></code></pre>



<a id="@Specification_1_public_key_from_bytes_with_pop"></a>

### Function `public_key_from_bytes_with_pop`


<pre><code>public fun public_key_from_bytes_with_pop(pk_bytes: vector&lt;u8&gt;, pop: &amp;bls12381::ProofOfPossession): option::Option&lt;bls12381::PublicKeyWithPoP&gt;<br/></code></pre>




<pre><code>pragma opaque;<br/>aborts_if false;<br/>ensures spec_verify_proof_of_possession_internal(pk_bytes, pop.bytes) &#61;&#61;&gt; (std::option::spec_is_some(result) &amp;&amp; std::option::spec_borrow(result).bytes &#61;&#61; pk_bytes);<br/>ensures !spec_verify_proof_of_possession_internal(pk_bytes, pop.bytes) &#61;&#61;&gt; std::option::spec_is_none(result);<br/>ensures [abstract] result &#61;&#61; spec_public_key_from_bytes_with_pop(pk_bytes, pop);<br/></code></pre>



<a id="@Specification_1_aggregate_pubkeys"></a>

### Function `aggregate_pubkeys`


<pre><code>public fun aggregate_pubkeys(public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;): bls12381::AggrPublicKeysWithPoP<br/></code></pre>




<pre><code>let bytes &#61; spec_aggregate_pubkeys_internal_1(public_keys);<br/>let success &#61; spec_aggregate_pubkeys_internal_2(public_keys);<br/>aborts_if !success;<br/>ensures result.bytes &#61;&#61; bytes;<br/></code></pre>



<a id="@Specification_1_aggregate_signatures"></a>

### Function `aggregate_signatures`


<pre><code>public fun aggregate_signatures(signatures: vector&lt;bls12381::Signature&gt;): option::Option&lt;bls12381::AggrOrMultiSignature&gt;<br/></code></pre>




<pre><code>aborts_if false;<br/>let bytes &#61; spec_aggregate_signatures_internal_1(signatures);<br/>let success &#61; spec_aggregate_signatures_internal_2(signatures);<br/>ensures success &#61;&#61;&gt; (std::option::spec_is_some(result) &amp;&amp; std::option::spec_borrow(result).bytes &#61;&#61; bytes);<br/>ensures !success &#61;&#61;&gt; std::option::spec_is_none(result);<br/></code></pre>



<a id="@Specification_1_aggr_or_multi_signature_from_bytes"></a>

### Function `aggr_or_multi_signature_from_bytes`


<pre><code>public fun aggr_or_multi_signature_from_bytes(bytes: vector&lt;u8&gt;): bls12381::AggrOrMultiSignature<br/></code></pre>




<pre><code>aborts_if len(bytes) !&#61; SIGNATURE_SIZE;<br/>ensures result.bytes &#61;&#61; bytes;<br/></code></pre>



<a id="@Specification_1_aggr_or_multi_signature_subgroup_check"></a>

### Function `aggr_or_multi_signature_subgroup_check`


<pre><code>public fun aggr_or_multi_signature_subgroup_check(signature: &amp;bls12381::AggrOrMultiSignature): bool<br/></code></pre>




<pre><code>aborts_if false;<br/>ensures result &#61;&#61; spec_signature_subgroup_check_internal(signature.bytes);<br/></code></pre>



<a id="@Specification_1_verify_aggregate_signature"></a>

### Function `verify_aggregate_signature`


<pre><code>public fun verify_aggregate_signature(aggr_sig: &amp;bls12381::AggrOrMultiSignature, public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;, messages: vector&lt;vector&lt;u8&gt;&gt;): bool<br/></code></pre>




<pre><code>aborts_if false;<br/>ensures result &#61;&#61; spec_verify_aggregate_signature_internal(aggr_sig.bytes, public_keys, messages);<br/></code></pre>



<a id="@Specification_1_verify_multisignature"></a>

### Function `verify_multisignature`


<pre><code>public fun verify_multisignature(multisig: &amp;bls12381::AggrOrMultiSignature, aggr_public_key: &amp;bls12381::AggrPublicKeysWithPoP, message: vector&lt;u8&gt;): bool<br/></code></pre>




<pre><code>aborts_if false;<br/>ensures result &#61;&#61; spec_verify_multisignature_internal(multisig.bytes, aggr_public_key.bytes, message);<br/></code></pre>



<a id="@Specification_1_verify_normal_signature"></a>

### Function `verify_normal_signature`


<pre><code>public fun verify_normal_signature(signature: &amp;bls12381::Signature, public_key: &amp;bls12381::PublicKey, message: vector&lt;u8&gt;): bool<br/></code></pre>




<pre><code>aborts_if false;<br/>ensures result &#61;&#61; spec_verify_normal_signature_internal(signature.bytes, public_key.bytes, message);<br/></code></pre>



<a id="@Specification_1_verify_signature_share"></a>

### Function `verify_signature_share`


<pre><code>public fun verify_signature_share(signature_share: &amp;bls12381::Signature, public_key: &amp;bls12381::PublicKeyWithPoP, message: vector&lt;u8&gt;): bool<br/></code></pre>




<pre><code>aborts_if false;<br/>ensures result &#61;&#61; spec_verify_signature_share_internal(signature_share.bytes, public_key.bytes, message);<br/></code></pre>



<a id="@Specification_1_aggregate_pubkeys_internal"></a>

### Function `aggregate_pubkeys_internal`


<pre><code>fun aggregate_pubkeys_internal(public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;): (vector&lt;u8&gt;, bool)<br/></code></pre>




<pre><code>pragma opaque;<br/>aborts_if [abstract] false;<br/>ensures result_1 &#61;&#61; spec_aggregate_pubkeys_internal_1(public_keys);<br/>ensures result_2 &#61;&#61; spec_aggregate_pubkeys_internal_2(public_keys);<br/></code></pre>



<a id="@Specification_1_aggregate_signatures_internal"></a>

### Function `aggregate_signatures_internal`


<pre><code>fun aggregate_signatures_internal(signatures: vector&lt;bls12381::Signature&gt;): (vector&lt;u8&gt;, bool)<br/></code></pre>




<pre><code>pragma opaque;<br/>aborts_if [abstract] false;<br/>ensures result_1 &#61;&#61; spec_aggregate_signatures_internal_1(signatures);<br/>ensures result_2 &#61;&#61; spec_aggregate_signatures_internal_2(signatures);<br/></code></pre>



<a id="@Specification_1_validate_pubkey_internal"></a>

### Function `validate_pubkey_internal`


<pre><code>fun validate_pubkey_internal(public_key: vector&lt;u8&gt;): bool<br/></code></pre>




<pre><code>pragma opaque;<br/>aborts_if [abstract] false;<br/>ensures result &#61;&#61; spec_validate_pubkey_internal(public_key);<br/></code></pre>



<a id="@Specification_1_signature_subgroup_check_internal"></a>

### Function `signature_subgroup_check_internal`


<pre><code>fun signature_subgroup_check_internal(signature: vector&lt;u8&gt;): bool<br/></code></pre>




<pre><code>pragma opaque;<br/>aborts_if [abstract] false;<br/>ensures result &#61;&#61; spec_signature_subgroup_check_internal(signature);<br/></code></pre>



<a id="@Specification_1_verify_aggregate_signature_internal"></a>

### Function `verify_aggregate_signature_internal`


<pre><code>fun verify_aggregate_signature_internal(aggsig: vector&lt;u8&gt;, public_keys: vector&lt;bls12381::PublicKeyWithPoP&gt;, messages: vector&lt;vector&lt;u8&gt;&gt;): bool<br/></code></pre>




<pre><code>pragma opaque;<br/>aborts_if [abstract] false;<br/>ensures result &#61;&#61; spec_verify_aggregate_signature_internal(aggsig, public_keys, messages);<br/></code></pre>



<a id="@Specification_1_verify_multisignature_internal"></a>

### Function `verify_multisignature_internal`


<pre><code>fun verify_multisignature_internal(multisignature: vector&lt;u8&gt;, agg_public_key: vector&lt;u8&gt;, message: vector&lt;u8&gt;): bool<br/></code></pre>




<pre><code>pragma opaque;<br/>aborts_if [abstract] false;<br/>ensures result &#61;&#61; spec_verify_multisignature_internal(multisignature, agg_public_key, message);<br/></code></pre>



<a id="@Specification_1_verify_normal_signature_internal"></a>

### Function `verify_normal_signature_internal`


<pre><code>fun verify_normal_signature_internal(signature: vector&lt;u8&gt;, public_key: vector&lt;u8&gt;, message: vector&lt;u8&gt;): bool<br/></code></pre>




<pre><code>pragma opaque;<br/>aborts_if [abstract] false;<br/>ensures result &#61;&#61; spec_verify_normal_signature_internal(signature, public_key, message);<br/></code></pre>



<a id="@Specification_1_verify_proof_of_possession_internal"></a>

### Function `verify_proof_of_possession_internal`


<pre><code>fun verify_proof_of_possession_internal(public_key: vector&lt;u8&gt;, proof_of_possesion: vector&lt;u8&gt;): bool<br/></code></pre>




<pre><code>pragma opaque;<br/>aborts_if [abstract] false;<br/>ensures result &#61;&#61; spec_verify_proof_of_possession_internal(public_key, proof_of_possesion);<br/></code></pre>



<a id="@Specification_1_verify_signature_share_internal"></a>

### Function `verify_signature_share_internal`


<pre><code>fun verify_signature_share_internal(signature_share: vector&lt;u8&gt;, public_key: vector&lt;u8&gt;, message: vector&lt;u8&gt;): bool<br/></code></pre>




<pre><code>pragma opaque;<br/>aborts_if [abstract] false;<br/>ensures result &#61;&#61; spec_verify_signature_share_internal(signature_share, public_key, message);<br/></code></pre>


&#35; Helper functions


<a id="0x1_bls12381_spec_aggregate_pubkeys_internal_1"></a>


<pre><code>fun spec_aggregate_pubkeys_internal_1(public_keys: vector&lt;PublicKeyWithPoP&gt;): vector&lt;u8&gt;;<br/></code></pre>




<a id="0x1_bls12381_spec_public_key_from_bytes_with_pop"></a>


<pre><code>fun spec_public_key_from_bytes_with_pop(pk_bytes: vector&lt;u8&gt;, pop: ProofOfPossession): Option&lt;PublicKeyWithPoP&gt;;<br/></code></pre>




<a id="0x1_bls12381_spec_aggregate_pubkeys_internal_2"></a>


<pre><code>fun spec_aggregate_pubkeys_internal_2(public_keys: vector&lt;PublicKeyWithPoP&gt;): bool;<br/></code></pre>




<a id="0x1_bls12381_spec_aggregate_signatures_internal_1"></a>


<pre><code>fun spec_aggregate_signatures_internal_1(signatures: vector&lt;Signature&gt;): vector&lt;u8&gt;;<br/></code></pre>




<a id="0x1_bls12381_spec_aggregate_signatures_internal_2"></a>


<pre><code>fun spec_aggregate_signatures_internal_2(signatures: vector&lt;Signature&gt;): bool;<br/></code></pre>




<a id="0x1_bls12381_spec_validate_pubkey_internal"></a>


<pre><code>fun spec_validate_pubkey_internal(public_key: vector&lt;u8&gt;): bool;<br/></code></pre>




<a id="0x1_bls12381_spec_signature_subgroup_check_internal"></a>


<pre><code>fun spec_signature_subgroup_check_internal(signature: vector&lt;u8&gt;): bool;<br/></code></pre>




<a id="0x1_bls12381_spec_verify_aggregate_signature_internal"></a>


<pre><code>fun spec_verify_aggregate_signature_internal(<br/>   aggsig: vector&lt;u8&gt;,<br/>   public_keys: vector&lt;PublicKeyWithPoP&gt;,<br/>   messages: vector&lt;vector&lt;u8&gt;&gt;,<br/>): bool;<br/></code></pre>




<a id="0x1_bls12381_spec_verify_multisignature_internal"></a>


<pre><code>fun spec_verify_multisignature_internal(<br/>   multisignature: vector&lt;u8&gt;,<br/>   agg_public_key: vector&lt;u8&gt;,<br/>   message: vector&lt;u8&gt;<br/>): bool;<br/></code></pre>




<a id="0x1_bls12381_spec_verify_normal_signature_internal"></a>


<pre><code>fun spec_verify_normal_signature_internal(<br/>   signature: vector&lt;u8&gt;,<br/>   public_key: vector&lt;u8&gt;,<br/>   message: vector&lt;u8&gt;<br/>): bool;<br/></code></pre>




<a id="0x1_bls12381_spec_verify_proof_of_possession_internal"></a>


<pre><code>fun spec_verify_proof_of_possession_internal(<br/>   public_key: vector&lt;u8&gt;,<br/>   proof_of_possesion: vector&lt;u8&gt;<br/>): bool;<br/></code></pre>




<a id="0x1_bls12381_spec_verify_signature_share_internal"></a>


<pre><code>fun spec_verify_signature_share_internal(<br/>   signature_share: vector&lt;u8&gt;,<br/>   public_key: vector&lt;u8&gt;,<br/>   message: vector&lt;u8&gt;<br/>): bool;<br/></code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY
